<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>CLISH: bintree</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.1 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="dirs.html"><span>Directories</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<h1>bintree<br>
<small>
[<a class="el" href="group__lub.html">&quot;Little Useful Bits&quot; Library</a>]</small>
</h1>This interface provides a facility which enables a client to order and access a set of arbitary data in a binary "tree".  
<a href="#_details">More...</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlub__bintree__node__s.html">lub_bintree_node_s</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlub__bintree__key__s.html">lub_bintree_key_s</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlub__bintree__s.html">lub_bintree_s</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlub__bintree__iterator__s.html">lub_bintree_iterator_s</a></td></tr>

<tr><td colspan="2"><br><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lub__bintree.html#g1c9a1626fd0ae7434a3f8b86c708fc3e">lub_bintree_MAX_KEY_STORAGE</a>&nbsp;&nbsp;&nbsp;(200)</td></tr>

<tr><td colspan="2"><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="structlub__bintree__node__s.html">lub_bintree_node_s</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lub__bintree.html#g2101d4d961de89d033eaa60266c2fa95">lub_bintree_node_t</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lub__bintree.html#gdad305572ae39108c6e51bd4f0082174">lub_bintree_compare_fn</a> (const void *clientnode, const void *clientkey)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="structlub__bintree__key__s.html">lub_bintree_key_s</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lub__bintree.html#g581beee31a9b9f85de5aa598655e5464">lub_bintree_key_t</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lub__bintree.html#g92801dcdd966cdb3e468887be72948d6">lub_bintree_getkey_fn</a> (const void *clientnode, <a class="el" href="structlub__bintree__key__s.html">lub_bintree_key_t</a> *key)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="structlub__bintree__s.html">lub_bintree_s</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lub__bintree.html#ga993f23d17da56188ff3133db8fd1481">lub_bintree_t</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="structlub__bintree__iterator__s.html">lub_bintree_iterator_s</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lub__bintree.html#gd538650cf915ef397dd5bca4b2d17f25">lub_bintree_iterator_t</a></td></tr>

<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lub__bintree.html#g060904afb8a8f4c8576759e03f61dbfb">lub_bintree_init</a> (<a class="el" href="structlub__bintree__s.html">lub_bintree_t</a> *tree, size_t node_offset, <a class="el" href="group__lub__bintree.html#gdad305572ae39108c6e51bd4f0082174">lub_bintree_compare_fn</a> compareFn, <a class="el" href="group__lub__bintree.html#g92801dcdd966cdb3e468887be72948d6">lub_bintree_getkey_fn</a> getkeyFn)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lub__bintree.html#g162cbfc65ef744003de0e467439cfce5">lub_bintree_node_init</a> (<a class="el" href="structlub__bintree__node__s.html">lub_bintree_node_t</a> *node)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lub__bintree.html#gaca639893f87ab6d0156724f8c61f214">lub_bintree_insert</a> (<a class="el" href="structlub__bintree__s.html">lub_bintree_t</a> *tree, void *clientnode)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lub__bintree.html#g584caf540a1f2d2299ba1d7bf8ef5d2d">lub_bintree_remove</a> (<a class="el" href="structlub__bintree__s.html">lub_bintree_t</a> *tree, void *clientnode)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lub__bintree.html#g1183defe99832a1b155d9ba2c8102cd3">lub_bintree_findfirst</a> (<a class="el" href="structlub__bintree__s.html">lub_bintree_t</a> *tree)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lub__bintree.html#g763a7f698169cdfb851246ee6d61da91">lub_bintree_findlast</a> (<a class="el" href="structlub__bintree__s.html">lub_bintree_t</a> *tree)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lub__bintree.html#g606e4b36e464b981f9fea9da7939cc70">lub_bintree_find</a> (<a class="el" href="structlub__bintree__s.html">lub_bintree_t</a> *tree, const void *key)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lub__bintree.html#g444573145c334757f359356adbaa4b35">lub_bintree_findnext</a> (<a class="el" href="structlub__bintree__s.html">lub_bintree_t</a> *tree, const void *key)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lub__bintree.html#ge87d1b320e8749cca319dbee35545bfb">lub_bintree_findprevious</a> (<a class="el" href="structlub__bintree__s.html">lub_bintree_t</a> *tree, const void *key)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lub__bintree.html#g1db8d40045b85aeb6d7c5f2d4f578b38">lub_bintree_iterator_init</a> (<a class="el" href="structlub__bintree__iterator__s.html">lub_bintree_iterator_t</a> *iter, <a class="el" href="structlub__bintree__s.html">lub_bintree_t</a> *tree, const void *clientnode)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lub__bintree.html#g701bdd6107364ba90c3e0bf6244f4171">lub_bintree_iterator_next</a> (<a class="el" href="structlub__bintree__iterator__s.html">lub_bintree_iterator_t</a> *iter)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lub__bintree.html#g4341b3586d0114c13682375f0bcd68b1">lub_bintree_iterator_previous</a> (<a class="el" href="structlub__bintree__iterator__s.html">lub_bintree_iterator_t</a> *iter)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lub__bintree.html#g20c81edd1187caee4d3fce019a6b7bc0">lub_bintree_dump</a> (<a class="el" href="structlub__bintree__s.html">lub_bintree_t</a> *tree)</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
This interface provides a facility which enables a client to order and access a set of arbitary data in a binary "tree". 
<p>
Each "tree" is defined by a number of "clientnodes" which are ordered according to a client defined "key".<p>
A "clientkey" is a client specific entity which can be compared with a "clientnode" to determine which is the "greatest". In order to do this the client needs provide a comparison function for comparing a "clientnode" with a "clientkey", and a function to convert a "clientnode" into a "clientkey".<p>
The client is responsible for providing each "clientnode" in a tree. This will typically contain some client specific data, but will also need to contain a bintree "node" which is used to structurally relate each node to one another in the tree. A specific "node" may only belong to one tree at a time, but an individual "clientnode" may contain multiple of these if necessary.<p>
<dl class="user" compact><dt><b>Implementation</b></dt><dd>The implementation of this interface uses a top-down splaying algorithm.</dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>"Splay trees", or "self-adjusting search trees" are a simple and efficient data structure for storing an ordered set. The data structure consists of a binary tree, without parent pointers, and no additional fields. It allows searching, insertion, deletion, deletemin, deletemax, splitting, joining, and many other operations, all with amortized logarithmic performance. Since the trees adapt to the sequence of requests, their performance on real access patterns is typically even better. Splay trees are described in a number of texts and papers [1,2,3,4,5].</dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>The code here is adapted from simple top-down splay, at the bottom of page 669 of [3]. It can be obtained via anonymous ftp from spade.pc.cs.cmu.edu in directory /usr/sleator/public.</dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>The chief modification here is that the splay operation works even if the item being splayed is not in the tree, and even if the tree root of the tree is NULL. So the line:</dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>t = splay(i, t);</dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>causes it to search for item with key i in the tree rooted at t. If it's there, it is splayed to the root. If it isn't there, then the node put at the root is the last one before NULL that would have been reached in a normal binary search for i. (It's a neighbor of i in the tree.) This allows many other operations to be easily implemented.</dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>[1] "Fundamentals of data structures in C", Horowitz, Sahni, and Anderson-Freed, Computer Science Press, pp 542-547.</dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>[2] "Data Structures and Their Algorithms", Lewis and Denenberg, Harper Collins, 1991, pp 243-251.</dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>[3] "Self-adjusting Binary Search Trees" Sleator and Tarjan, JACM Volume 32, No 3, July 1985, pp 652-686.</dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>[4] "Data Structure and Algorithm Analysis", Mark Weiss, Benjamin Cummins, 1992, pp 119-130.</dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>[5] "Data Structures, Algorithms, and Performance", Derick Wood, Addison-Wesley, 1993, pp 367-375.</dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>The splay function is based on one written by Daniel Sleator, which is released in the public domain.</dd></dl>
<dl class="author" compact><dt><b>Author:</b></dt><dd>Graeme McKerrell </dd></dl>
<dl class="date" compact><dt><b>Date:</b></dt><dd>Created On : Fri Jan 23 12:50:18 2004 </dd></dl>
<dl class="version" compact><dt><b>Version:</b></dt><dd>TESTED </dd></dl>
<hr><h2>Define Documentation</h2>
<a class="anchor" name="g1c9a1626fd0ae7434a3f8b86c708fc3e"></a><!-- doxytag: member="bintree.h::lub_bintree_MAX_KEY_STORAGE" ref="g1c9a1626fd0ae7434a3f8b86c708fc3e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define lub_bintree_MAX_KEY_STORAGE&nbsp;&nbsp;&nbsp;(200)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This is used to size the key storage area for an opaque key. If any client requires a greater storage size then this will need to be increased. 
</div>
</div><p>
<hr><h2>Typedef Documentation</h2>
<a class="anchor" name="gdad305572ae39108c6e51bd4f0082174"></a><!-- doxytag: member="bintree.h::lub_bintree_compare_fn" ref="gdad305572ae39108c6e51bd4f0082174" args="(const void *clientnode, const void *clientkey)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int <a class="el" href="group__lub__bintree.html#gdad305572ae39108c6e51bd4f0082174">lub_bintree_compare_fn</a>(const void *clientnode, const void *clientkey)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This type defines a callback function which will compare two "keys" with each other<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>clientnode</em>&nbsp;</td><td>the client node to compare </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientkey</em>&nbsp;</td><td>the key to compare with a node</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>&lt;0 if clientnode &lt; clientkey; 0 if clientnode == clientkey; &gt;0 if clientnode &gt; clientkey </dd></dl>

</div>
</div><p>
<a class="anchor" name="g92801dcdd966cdb3e468887be72948d6"></a><!-- doxytag: member="bintree.h::lub_bintree_getkey_fn" ref="g92801dcdd966cdb3e468887be72948d6" args="(const void *clientnode, lub_bintree_key_t *key)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void <a class="el" href="group__lub__bintree.html#g92801dcdd966cdb3e468887be72948d6">lub_bintree_getkey_fn</a>(const void *clientnode, <a class="el" href="structlub__bintree__key__s.html">lub_bintree_key_t</a> *key)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This type defines a callback function which will convert a client's "node" into a search "key"<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>clientnode</em>&nbsp;</td><td>the node from which to derive a key </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>a reference to the key to fill out</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A "key" which corresponds the "node" in this view </dd></dl>

</div>
</div><p>
<a class="anchor" name="gd538650cf915ef397dd5bca4b2d17f25"></a><!-- doxytag: member="bintree.h::lub_bintree_iterator_t" ref="gd538650cf915ef397dd5bca4b2d17f25" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structlub__bintree__iterator__s.html">lub_bintree_iterator_s</a> <a class="el" href="structlub__bintree__iterator__s.html">lub_bintree_iterator_t</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This is used to perform iterations of a tree 
</div>
</div><p>
<a class="anchor" name="g581beee31a9b9f85de5aa598655e5464"></a><!-- doxytag: member="bintree.h::lub_bintree_key_t" ref="g581beee31a9b9f85de5aa598655e5464" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structlub__bintree__key__s.html">lub_bintree_key_s</a> <a class="el" href="structlub__bintree__key__s.html">lub_bintree_key_t</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This is used to declare an opaque key structure Typically a client would declare their own non-opaque structure which they would fill out appropriately 
</div>
</div><p>
<a class="anchor" name="g2101d4d961de89d033eaa60266c2fa95"></a><!-- doxytag: member="bintree.h::lub_bintree_node_t" ref="g2101d4d961de89d033eaa60266c2fa95" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structlub__bintree__node__s.html">lub_bintree_node_s</a> <a class="el" href="structlub__bintree__node__s.html">lub_bintree_node_t</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This type represents a bintree "node". Typically the client will have a "clientnode" structure which contains it's data. A bintree "node" is made one of the data elements of that structure. When the tree is initialised the client provides the offset into the structure of the "node" which is to be used for that tree. 
</div>
</div><p>
<a class="anchor" name="ga993f23d17da56188ff3133db8fd1481"></a><!-- doxytag: member="bintree.h::lub_bintree_t" ref="ga993f23d17da56188ff3133db8fd1481" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structlub__bintree__s.html">lub_bintree_s</a> <a class="el" href="structlub__bintree__s.html">lub_bintree_t</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This type represents an binary tree instance 
</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="g20c81edd1187caee4d3fce019a6b7bc0"></a><!-- doxytag: member="bintree.h::lub_bintree_dump" ref="g20c81edd1187caee4d3fce019a6b7bc0" args="(lub_bintree_t *tree)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lub_bintree_dump           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlub__bintree__s.html">lub_bintree_t</a> *&nbsp;</td>
          <td class="paramname"> <em>tree</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This operation dumps the node list of the specified tree to stdout<p>
<dl class="pre" compact><dt><b>Precondition:</b></dt><dd>The tree must be initialised</dd></dl>
<dl class="post" compact><dt><b>Postcondition:</b></dt><dd>The structure of the tree will be unaltered. </dd></dl>
<dl compact><dt><b>Parameters: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>tree</em>&nbsp;</td><td>
the "tree" instance to invoke this operation upon </td></tr>
</table>
</dl>
</div>
</div><p>
<a class="anchor" name="g606e4b36e464b981f9fea9da7939cc70"></a><!-- doxytag: member="bintree.h::lub_bintree_find" ref="g606e4b36e464b981f9fea9da7939cc70" args="(lub_bintree_t *tree, const void *key)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* lub_bintree_find           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlub__bintree__s.html">lub_bintree_t</a> *&nbsp;</td>
          <td class="paramname"> <em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>key</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This operation searches the specified "tree" for a "clientnode" which matches the specified "key"<p>
<dl class="pre" compact><dt><b>Precondition:</b></dt><dd>The tree must be initialised</dd></dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>"clientnode" instance or NULL if no node is found. </dd></dl>
<dl compact><dt><b>Parameters: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>tree</em>&nbsp;</td><td>
the "tree" instance to invoke this operation upon </td></tr>
<tr><td valign="top"><em>key</em>&nbsp;</td><td>
the "key" to search with </td></tr>
</table>
</dl>
</div>
</div><p>
<a class="anchor" name="g1183defe99832a1b155d9ba2c8102cd3"></a><!-- doxytag: member="bintree.h::lub_bintree_findfirst" ref="g1183defe99832a1b155d9ba2c8102cd3" args="(lub_bintree_t *tree)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* lub_bintree_findfirst           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlub__bintree__s.html">lub_bintree_t</a> *&nbsp;</td>
          <td class="paramname"> <em>tree</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This operation returns the first "clientnode" present in the specified "tree"<p>
<dl class="pre" compact><dt><b>Precondition:</b></dt><dd>The tree must be initialised</dd></dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>"clientnode" instance or NULL if no nodes are present in this tree. </dd></dl>
<dl compact><dt><b>Parameters: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>tree</em>&nbsp;</td><td>
the "tree" instance to invoke this operation upon </td></tr>
</table>
</dl>
</div>
</div><p>
<a class="anchor" name="g763a7f698169cdfb851246ee6d61da91"></a><!-- doxytag: member="bintree.h::lub_bintree_findlast" ref="g763a7f698169cdfb851246ee6d61da91" args="(lub_bintree_t *tree)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* lub_bintree_findlast           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlub__bintree__s.html">lub_bintree_t</a> *&nbsp;</td>
          <td class="paramname"> <em>tree</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This operation returns the last "clientnode" present in the specified "tree"<p>
<dl class="pre" compact><dt><b>Precondition:</b></dt><dd>The tree must be initialised</dd></dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>"clientnode" instance or NULL if no nodes are present in this tree. </dd></dl>
<dl compact><dt><b>Parameters: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>tree</em>&nbsp;</td><td>
the "tree" instance to invoke this operation upon </td></tr>
</table>
</dl>
</div>
</div><p>
<a class="anchor" name="g444573145c334757f359356adbaa4b35"></a><!-- doxytag: member="bintree.h::lub_bintree_findnext" ref="g444573145c334757f359356adbaa4b35" args="(lub_bintree_t *tree, const void *key)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* lub_bintree_findnext           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlub__bintree__s.html">lub_bintree_t</a> *&nbsp;</td>
          <td class="paramname"> <em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>key</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This operation searches the specified "tree" for a "clientnode" which is the one which logically follows the specified "key"<p>
A "clientnode" with the specified "key" doesn't need to be in the tree.<p>
<dl class="pre" compact><dt><b>Precondition:</b></dt><dd>The tree must be initialised</dd></dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>"clientnode" instance or NULL if no node is found. </dd></dl>
<dl compact><dt><b>Parameters: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>tree</em>&nbsp;</td><td>
the "tree" instance to invoke this operation upon </td></tr>
<tr><td valign="top"><em>key</em>&nbsp;</td><td>
the "key" to search with </td></tr>
</table>
</dl>
</div>
</div><p>
<a class="anchor" name="ge87d1b320e8749cca319dbee35545bfb"></a><!-- doxytag: member="bintree.h::lub_bintree_findprevious" ref="ge87d1b320e8749cca319dbee35545bfb" args="(lub_bintree_t *tree, const void *key)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* lub_bintree_findprevious           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlub__bintree__s.html">lub_bintree_t</a> *&nbsp;</td>
          <td class="paramname"> <em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>key</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This operation searches the specified "tree" for a "clientnode" which is the one which logically preceeds the specified "key"<p>
A "clientnode" with the specified "key" doesn't need to be in the tree.<p>
<dl class="pre" compact><dt><b>Precondition:</b></dt><dd>The tree must be initialised</dd></dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>"clientnode" instance or NULL if no node is found. </dd></dl>
<dl compact><dt><b>Parameters: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>tree</em>&nbsp;</td><td>
the "tree" instance to invoke this operation upon </td></tr>
<tr><td valign="top"><em>key</em>&nbsp;</td><td>
the "key" to search with </td></tr>
</table>
</dl>
</div>
</div><p>
<a class="anchor" name="g060904afb8a8f4c8576759e03f61dbfb"></a><!-- doxytag: member="bintree.h::lub_bintree_init" ref="g060904afb8a8f4c8576759e03f61dbfb" args="(lub_bintree_t *tree, size_t node_offset, lub_bintree_compare_fn compareFn, lub_bintree_getkey_fn getkeyFn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lub_bintree_init           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlub__bintree__s.html">lub_bintree_t</a> *&nbsp;</td>
          <td class="paramname"> <em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>node_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__lub__bintree.html#gdad305572ae39108c6e51bd4f0082174">lub_bintree_compare_fn</a>&nbsp;</td>
          <td class="paramname"> <em>compareFn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__lub__bintree.html#g92801dcdd966cdb3e468887be72948d6">lub_bintree_getkey_fn</a>&nbsp;</td>
          <td class="paramname"> <em>getkeyFn</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This operation initialises an instance of a binary tree.<p>
<dl class="pre" compact><dt><b>Precondition:</b></dt><dd>none</dd></dl>
<dl class="post" compact><dt><b>Postcondition:</b></dt><dd>The tree is ready to have client nodes inserted. </dd></dl>
<dl compact><dt><b>Parameters: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>tree</em>&nbsp;</td><td>
the "tree" instance to initialise </td></tr>
<tr><td valign="top"><em>node_offset</em>&nbsp;</td><td>
the offset of the bintree "node" structure within the "clientnode" structure. This is typically passed using the offsetof() macro. </td></tr>
<tr><td valign="top"><em>compareFn</em>&nbsp;</td><td>
a comparison function for comparing a "clientnode" with a "clientkey" </td></tr>
<tr><td valign="top"><em>getkeyFn</em>&nbsp;</td><td>
a function which will fill out a "key" from a clientnode </td></tr>
</table>
</dl>
</div>
</div><p>
<a class="anchor" name="gaca639893f87ab6d0156724f8c61f214"></a><!-- doxytag: member="bintree.h::lub_bintree_insert" ref="gaca639893f87ab6d0156724f8c61f214" args="(lub_bintree_t *tree, void *clientnode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int lub_bintree_insert           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlub__bintree__s.html">lub_bintree_t</a> *&nbsp;</td>
          <td class="paramname"> <em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>clientnode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This operation adds a client node to the specified tree.<p>
<dl class="pre" compact><dt><b>Precondition:</b></dt><dd>The tree must be initialised <p>
The clientnode must be initialised</dd></dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 if the "clientnode" is added correctly to the tree. If another "clientnode" already exists in the tree with the same key, then -1 is returned, and the tree remains unchanged.</dd></dl>
<dl class="post" compact><dt><b>Postcondition:</b></dt><dd>If the bintree "node" is already part of a tree, then an assert will fire. </dd></dl>
<dl compact><dt><b>Parameters: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>tree</em>&nbsp;</td><td>
the "tree" instance to invoke this operation upon </td></tr>
<tr><td valign="top"><em>clientnode</em>&nbsp;</td><td>
a pointer to a client node. NB the tree can find the necessary lub_BintreeNodeT from it's stored offset. </td></tr>
</table>
</dl>
</div>
</div><p>
<a class="anchor" name="g1db8d40045b85aeb6d7c5f2d4f578b38"></a><!-- doxytag: member="bintree.h::lub_bintree_iterator_init" ref="g1db8d40045b85aeb6d7c5f2d4f578b38" args="(lub_bintree_iterator_t *iter, lub_bintree_t *tree, const void *clientnode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lub_bintree_iterator_init           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlub__bintree__iterator__s.html">lub_bintree_iterator_t</a> *&nbsp;</td>
          <td class="paramname"> <em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlub__bintree__s.html">lub_bintree_t</a> *&nbsp;</td>
          <td class="paramname"> <em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>clientnode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This operation initialises an iterator. This can then be subsequently used for iterating through a tree. This will work even if the "clientnode" which defined the current iterator has been removed before the next iterator operation.<p>
<dl class="pre" compact><dt><b>Precondition:</b></dt><dd>The tree must be initialised <p>
The clientnode must be initialised and valid at the time of this call</dd></dl>
<dl class="post" compact><dt><b>Postcondition:</b></dt><dd>The interator instance will be updated to reference the position in the tree for the clientnode. </dd></dl>
<dl compact><dt><b>Parameters: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>iter</em>&nbsp;</td><td>
the iterator instance to initialise </td></tr>
<tr><td valign="top"><em>tree</em>&nbsp;</td><td>
the tree to associate with this iterator </td></tr>
<tr><td valign="top"><em>clientnode</em>&nbsp;</td><td>
the starting point for the iteration </td></tr>
</table>
</dl>
</div>
</div><p>
<a class="anchor" name="g701bdd6107364ba90c3e0bf6244f4171"></a><!-- doxytag: member="bintree.h::lub_bintree_iterator_next" ref="g701bdd6107364ba90c3e0bf6244f4171" args="(lub_bintree_iterator_t *iter)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* lub_bintree_iterator_next           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlub__bintree__iterator__s.html">lub_bintree_iterator_t</a> *&nbsp;</td>
          <td class="paramname"> <em>iter</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This operation returns the next "clientnode" in an iteration.<p>
<dl class="pre" compact><dt><b>Precondition:</b></dt><dd>The interator instance must have been initialised</dd></dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>"clientnode" instance or NULL if the iteration has reached the end of the tree.</dd></dl>
<dl class="post" compact><dt><b>Postcondition:</b></dt><dd>The interator instance will be updated to reference the position in the tree for the returned value. </dd></dl>
<dl compact><dt><b>Parameters: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>iter</em>&nbsp;</td><td>
the iterator instance to invoke this operation upon. </td></tr>
</table>
</dl>
</div>
</div><p>
<a class="anchor" name="g4341b3586d0114c13682375f0bcd68b1"></a><!-- doxytag: member="bintree.h::lub_bintree_iterator_previous" ref="g4341b3586d0114c13682375f0bcd68b1" args="(lub_bintree_iterator_t *iter)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* lub_bintree_iterator_previous           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlub__bintree__iterator__s.html">lub_bintree_iterator_t</a> *&nbsp;</td>
          <td class="paramname"> <em>iter</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This operation returns the previous "clientnode" in an iteration.<p>
<dl class="pre" compact><dt><b>Precondition:</b></dt><dd>The interator instance must have been initialised</dd></dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>"clientnode" instance or NULL if the iteration has reached the beginning of the tree.</dd></dl>
<dl class="post" compact><dt><b>Postcondition:</b></dt><dd>The interator instance will be updated to reference the position in the tree for the returned value. </dd></dl>
<dl compact><dt><b>Parameters: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>iter</em>&nbsp;</td><td>
the iterator instance to invoke this operation upon. </td></tr>
</table>
</dl>
</div>
</div><p>
<a class="anchor" name="g162cbfc65ef744003de0e467439cfce5"></a><!-- doxytag: member="bintree.h::lub_bintree_node_init" ref="g162cbfc65ef744003de0e467439cfce5" args="(lub_bintree_node_t *node)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lub_bintree_node_init           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlub__bintree__node__s.html">lub_bintree_node_t</a> *&nbsp;</td>
          <td class="paramname"> <em>node</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This operation is called to initialise a "clientnode" ready for insertion into a tree. This is only required once after the memory for a node has been allocated.<p>
<dl class="pre" compact><dt><b>Precondition:</b></dt><dd>none</dd></dl>
<dl class="post" compact><dt><b>Postcondition:</b></dt><dd>The node is ready to be inserted into a tree. </dd></dl>
<dl compact><dt><b>Parameters: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>node</em>&nbsp;</td><td>
the bintree node to initialise </td></tr>
</table>
</dl>
</div>
</div><p>
<a class="anchor" name="g584caf540a1f2d2299ba1d7bf8ef5d2d"></a><!-- doxytag: member="bintree.h::lub_bintree_remove" ref="g584caf540a1f2d2299ba1d7bf8ef5d2d" args="(lub_bintree_t *tree, void *clientnode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lub_bintree_remove           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlub__bintree__s.html">lub_bintree_t</a> *&nbsp;</td>
          <td class="paramname"> <em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>clientnode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This operation removes a "clientnode" from the specified "tree"<p>
<dl class="pre" compact><dt><b>Precondition:</b></dt><dd>The tree must be initialised <p>
The clientnode must be initialised</dd></dl>
<dl class="post" compact><dt><b>Postcondition:</b></dt><dd>The "clientnode" will no longer be part of the specified tree, and will be made available for re-insertion <p>
If the clientnode is not present in the specified tree, then an assert will fire. </dd></dl>
<dl compact><dt><b>Parameters: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>tree</em>&nbsp;</td><td>
the "tree" instance to invoke this operation upon </td></tr>
<tr><td valign="top"><em>clientnode</em>&nbsp;</td><td>
the node to remove </td></tr>
</table>
</dl>
</div>
</div><p>
<hr size="1"><address style="align: right;"><small>Generated on Tue Apr 29 13:41:08 2008 for CLISH by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.1 </small></address>
</body>
</html>
