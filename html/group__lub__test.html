<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>CLISH: test</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.1 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="dirs.html"><span>Directories</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<h1>test<br>
<small>
[<a class="el" href="group__lub.html">&quot;Little Useful Bits&quot; Library</a>]</small>
</h1>This utiltiy provides a simple unittest facility.  
<a href="#_details">More...</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lub__test.html#g5cd77c431b404117a4559b252e8c8250">lub_test_status_t</a> { <a class="el" href="group__lub__test.html#gg5cd77c431b404117a4559b252e8c8250ddcfe87363f3d94eb20da28b16c73006">LUB_TEST_PASS</a>, 
<a class="el" href="group__lub__test.html#gg5cd77c431b404117a4559b252e8c82502abea550670b816f48c83602c875c0de">LUB_TEST_FAIL</a>
 }</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lub__test.html#g3ca4834aa313ca4b054f4ef42973f30b">lub_test_verbosity_t</a> { <a class="el" href="group__lub__test.html#gg3ca4834aa313ca4b054f4ef42973f30b0469b14d018b29b2d669cdc0f0b73681">LUB_TEST_TERSE</a> = 0, 
<a class="el" href="group__lub__test.html#gg3ca4834aa313ca4b054f4ef42973f30b5f5b5e4642908d35bcba9057b29b0a86">LUB_TEST_NORMAL</a>, 
<a class="el" href="group__lub__test.html#gg3ca4834aa313ca4b054f4ef42973f30b5f82c5f84f00bdb122b09d6f257aed35">LUB_TEST_VERBOSE</a>
 }</td></tr>

<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lub__test.html#gcc91ccd7ddbe72414bff9628d70cfda1">lub_test_parse_command_line</a> (int argc, const char *const *argv)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lub__test.html#g47a56e695cab95b0c8140e677e8dafd0">lub_test_begin</a> (const char *fmt,...)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lub__test.html#gf5e98e92393bc3cfed4ae1300196fa47">lub_test_log</a> (<a class="el" href="group__lub__test.html#g3ca4834aa313ca4b054f4ef42973f30b">lub_test_verbosity_t</a> level, const char *fmt,...)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__lub__test.html#g5cd77c431b404117a4559b252e8c8250">lub_test_status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lub__test.html#gaa554b70566e82894b07e7f5a1c2fd3f">lub_test_get_status</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lub__test.html#g1aeb2ab3f2f66d5b8ba9e40e08916a17">lub_test_failure_count</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lub__test.html#g3a53c9523f6ee52bfaa3627f15107599">lub_test_end</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lub__test.html#g8e753db87b8c78b65c01279dd457c82b">lub_test_stop_here</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lub__test.html#gb8d7f63c4c76e413338d8f662be7965d">lub_test_seq_begin</a> (int seq, const char *fmt,...)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lub__test.html#gbae5fe10a0b054fc352def00b142c772">lub_test_seq_log</a> (<a class="el" href="group__lub__test.html#g3ca4834aa313ca4b054f4ef42973f30b">lub_test_verbosity_t</a> level, const char *fmt,...)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lub__test.html#g43608907f091e6f0b120db1907d25e0a">lub_test_seq_end</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__lub__test.html#g5cd77c431b404117a4559b252e8c8250">lub_test_status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lub__test.html#g4b0c5c8d20f15f93f3c159fb32926267">lub_test_check</a> (<a class="el" href="group__lub__types.html#g04dd5074964518403bf944f2b240a5f8">bool_t</a> expr, const char *fmt,...)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__lub__test.html#g5cd77c431b404117a4559b252e8c8250">lub_test_status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lub__test.html#g6dcf669c834d9a964a46f9d8d6d317bc">lub_test_check_int</a> (int expect, int actual, const char *fmt,...)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__lub__test.html#g5cd77c431b404117a4559b252e8c8250">lub_test_status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lub__test.html#g71ad94a82da5d0edd6ffe63c9e751dc4">lag_test_test_float</a> (double min, double max, double actual, const char *fmt,...)</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
This utiltiy provides a simple unittest facility. 
<p>
<dl class="user" compact><dt><b>Unit Testing Philosophy</b></dt><dd></dd></dl>
The tests are used during development as a means of exercising and debugging the new code, and once developed serve as a means of regression-testing to ensure that changes or additions have not introduced defects. Unit testing in this manner offers many benefits:<p>
<ul>
<li>Well designed unit tests allow for more complete exercise &amp; test coverage of new code.</li>
</ul>
<ul>
<li>They do not require product hardware or even a product simulator; they are compact, standalone executables.</li>
</ul>
<ul>
<li>It is easy to instrument the unit tests with commercial tools such as Purify/PureCoverage.</li>
</ul>
<ul>
<li>Use as regression tests increases code maintainability.</li>
</ul>
<ul>
<li>They can be run during builds as ``sanity-checks'' that components are functional.</li>
</ul>
<dl class="user" compact><dt><b>What is the unit test interface?</b></dt><dd></dd></dl>
The Unit Test Interface provide a set of basic capabilities that all unit tests need, and which are trivially easy to incorporate into a test. They make it easy to do things such as:<p>
<ul>
<li>Log output to the screen and/or to a logfile</li>
</ul>
<ul>
<li>Test values of various types and record the results</li>
</ul>
<ul>
<li>Provide well-formatted, concise output with controllable verbosity</li>
</ul>
<ul>
<li>Track test status.</li>
</ul>
<ul>
<li>Have a consistent set of command-line options for controlling the unit test behavior. (see unitTestCL() below)</li>
</ul>
<dl class="user" compact><dt><b>Verbosity</b></dt><dd></dd></dl>
Depending on the length of a test, why it is being run, and the stage of development, it is desirable to have different levels of detail output. The Unit Test Utilities provide three levels of detail:<p>
<ul>
<li><b>Terse</b> output is the minimal set. Only test failures, serious errors, and final results are logged.</li>
</ul>
<ul>
<li><b>Normal</b> output is the default. All test results, sequence headers, etc. are logged.</li>
</ul>
<ul>
<li><b>Verbose</b> output includes all output messages. This level is not used by the Utilities themselves but is useful for providing additional, detailed messages within unit tests.</li>
</ul>
Most Utility functions handle verbosity issues automatically; for example, Tests automatically log failures as ``terse'' and pass results as ``normal''. The only time a user needs to specify verbosity is with Log messages.<p>
All output has an associated Verbosity level, and will only be output if the current Verbosity setting is equal to or greater than that level.<p>
<dl class="user" compact><dt><b>Sequences</b></dt><dd></dd></dl>
Simple numbering of tests is adequate only for very small unit tests. More commonly, there are groups of related tests covering a particular function or set of functionality. This gives rise to the concept of Sequences. A Sequence assigns a name and number to a group of tests; within the sequence, tests are numbered automatically. While their use is not strictly required, the use of Sequences is encouraged as a means of organizing test output for easy understanding.<p>
Sequences are begun with a function call specifying their sequence number and a printf-style format specification of their name. This outputs a sequence header (at 'normal' verbosity) and resets the test counter. Another call ends the sequence.<p>
<dl class="user" compact><dt><b>Tests</b></dt><dd></dd></dl>
Tests are the heart of the unit test. Every test has a pass/fail result, which is returned as well as affecting the overall pass/fail status of the unit test. Every test also accepts a ``name'' argument (in printf style), and generates appropriate log output. Although null strings are accepted as names, naming each test is encouraged as it makes the output much more readable.<p>
At the Terse verbosity level, only failing tests generate log output.<p>
Test functions are provided for testing:<p>
<ul>
<li><b>Expressions:</b> the expression's true/false value is evaluated. This is the most basic test, similar to an assert(). Virtually anything can be tested using this, but the log output is minimal; only a Pass/Fail result and the test name are logged.</li>
</ul>
<ul>
<li><b>Integer</b> <b>Comparison:</b> the test function is passed an expected and actual value. The test passes if the values are the same. The log includes Pass/Fail, expected &amp; actual values, and the test name; because the values appear in the log, failures may be more easily investigated.</li>
</ul>
<ul>
<li><b>Float</b> <b>Comparison:</b> the test function is passed minimum, maximum, and actual values. The test passes if the actual value is less than or equal to maximum, and greater than or equal to minimum. Like the integer comparison, the min, max, and actual values are all logged in addition to the Pass/Fail result and test name.</li>
</ul>
The overall unit test pass/fail result can be requested at any time via a function call.<p>
<dl class="user" compact><dt><b>Logging</b></dt><dd></dd></dl>
Three different logging functions are provided. All are similar but each is appropriate for different purposes. Each function takes as its first argument a verbosity level, specifying the minimum verbosity at which the message should be logged. Each also takes a printf-style specification of format and arguments, which is used to generate the output. In this way anything can be output: strings, variables, formatted floats, whatever the unit test needs to record.<p>
Note that it is not required to use any logging function; the Utilities will generate a reasonable log based on the sequence and test calls. However, additional logging may add significant value and human readability to the test results.<p>
<dl class="author" compact><dt><b>Author:</b></dt><dd>Graeme McKerrell <p>
Brett B. Bonner </dd></dl>
<dl class="date" compact><dt><b>Date:</b></dt><dd>Created On Thu Feb 28 11:25:44 2002 <p>
Last Revised 03-Oct-2002 (BBB) </dd></dl>
<dl class="version" compact><dt><b>Version:</b></dt><dd>UNTESTED </dd></dl>
<hr><h2>Enumeration Type Documentation</h2>
<a class="anchor" name="g5cd77c431b404117a4559b252e8c8250"></a><!-- doxytag: member="test.h::lub_test_status_t" ref="g5cd77c431b404117a4559b252e8c8250" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__lub__test.html#g5cd77c431b404117a4559b252e8c8250">lub_test_status_t</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Status codes <dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="gg5cd77c431b404117a4559b252e8c8250ddcfe87363f3d94eb20da28b16c73006"></a><!-- doxytag: member="LUB_TEST_PASS" ref="gg5cd77c431b404117a4559b252e8c8250ddcfe87363f3d94eb20da28b16c73006" args="" -->LUB_TEST_PASS</em>&nbsp;</td><td>
Indicates a test has passed </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg5cd77c431b404117a4559b252e8c82502abea550670b816f48c83602c875c0de"></a><!-- doxytag: member="LUB_TEST_FAIL" ref="gg5cd77c431b404117a4559b252e8c82502abea550670b816f48c83602c875c0de" args="" -->LUB_TEST_FAIL</em>&nbsp;</td><td>
Indicates a test has failed </td></tr>
</table>
</dl>

</div>
</div><p>
<a class="anchor" name="g3ca4834aa313ca4b054f4ef42973f30b"></a><!-- doxytag: member="test.h::lub_test_verbosity_t" ref="g3ca4834aa313ca4b054f4ef42973f30b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__lub__test.html#g3ca4834aa313ca4b054f4ef42973f30b">lub_test_verbosity_t</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Message priority/verbosity levels <dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="gg3ca4834aa313ca4b054f4ef42973f30b0469b14d018b29b2d669cdc0f0b73681"></a><!-- doxytag: member="LUB_TEST_TERSE" ref="gg3ca4834aa313ca4b054f4ef42973f30b0469b14d018b29b2d669cdc0f0b73681" args="" -->LUB_TEST_TERSE</em>&nbsp;</td><td>
Only output test failures, errors and final result </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg3ca4834aa313ca4b054f4ef42973f30b5f5b5e4642908d35bcba9057b29b0a86"></a><!-- doxytag: member="LUB_TEST_NORMAL" ref="gg3ca4834aa313ca4b054f4ef42973f30b5f5b5e4642908d35bcba9057b29b0a86" args="" -->LUB_TEST_NORMAL</em>&nbsp;</td><td>
Output all test results, sequence headers, errors and results </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg3ca4834aa313ca4b054f4ef42973f30b5f82c5f84f00bdb122b09d6f257aed35"></a><!-- doxytag: member="LUB_TEST_VERBOSE" ref="gg3ca4834aa313ca4b054f4ef42973f30b5f82c5f84f00bdb122b09d6f257aed35" args="" -->LUB_TEST_VERBOSE</em>&nbsp;</td><td>
Output everything </td></tr>
</table>
</dl>

</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="g71ad94a82da5d0edd6ffe63c9e751dc4"></a><!-- doxytag: member="test.h::lag_test_test_float" ref="g71ad94a82da5d0edd6ffe63c9e751dc4" args="(double min, double max, double actual, const char *fmt,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__lub__test.html#g5cd77c431b404117a4559b252e8c8250">lub_test_status_t</a> lag_test_test_float           </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>actual</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function is designed to ensure that a floating point value is within acceptible limits. It takes a minimum, maximum and actual value. The test passes if the actual value is greater or equal than the minimum, and less than or equal to the maximum. All three values are recorded in the log output.<p>
<dl class="pre" compact><dt><b>Precondition:</b></dt><dd><ul>
<li><a class="el" href="group__lub__test.html#g47a56e695cab95b0c8140e677e8dafd0">lub_test_begin()</a> must have been called</li></ul>
</dd></dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A status code (LUB_TEST_PASS/LUB_TEST_FAIL)</dd></dl>
<dl class="post" compact><dt><b>Postcondition:</b></dt><dd><ul>
<li>The formatted scenario and result is reported in the logfile and/or stdout.</li><li>The test count is incremented by one.</li><li>If the tests fails then the overall unit-test status is changed to LUB_TEST_FAIL</li><li>If <a class="el" href="group__lub__test.html#g47a56e695cab95b0c8140e677e8dafd0">lub_test_begin()</a> has not been called the behaviour is undefined </li></ul>
</dd></dl>
<dl compact><dt><b>Parameters: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>min</em>&nbsp;</td><td>
the minimum acceptible value </td></tr>
<tr><td valign="top"><em>max</em>&nbsp;</td><td>
the maximum acceptible value </td></tr>
<tr><td valign="top"><em>actual</em>&nbsp;</td><td>
the actual value </td></tr>
<tr><td valign="top"><em>fmt</em>&nbsp;</td><td>
a printf style format string to specify the test scenario </td></tr>
</table>
</dl>
</div>
</div><p>
<a class="anchor" name="g47a56e695cab95b0c8140e677e8dafd0"></a><!-- doxytag: member="test.h::lub_test_begin" ref="g47a56e695cab95b0c8140e677e8dafd0" args="(const char *fmt,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lub_test_begin           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This starts and specifies the name for the unit-test.<p>
<dl class="pre" compact><dt><b>Precondition:</b></dt><dd><ul>
<li>lub_test_CL() must have been called.</li></ul>
</dd></dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>none</dd></dl>
<dl class="post" compact><dt><b>Postcondition:</b></dt><dd><ul>
<li>The begining of the test is reported in the logfile and/or stdout</li><li>The overall pass/fail status is reset. </li></ul>
</dd></dl>
<dl compact><dt><b>Parameters: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>fmt</em>&nbsp;</td><td>
a printf style format string to specify the name of the test </td></tr>
</table>
</dl>
</div>
</div><p>
<a class="anchor" name="g4b0c5c8d20f15f93f3c159fb32926267"></a><!-- doxytag: member="test.h::lub_test_check" ref="g4b0c5c8d20f15f93f3c159fb32926267" args="(bool_t expr, const char *fmt,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__lub__test.html#g5cd77c431b404117a4559b252e8c8250">lub_test_status_t</a> lub_test_check           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__lub__types.html#g04dd5074964518403bf944f2b240a5f8">bool_t</a>&nbsp;</td>
          <td class="paramname"> <em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The most basic test function, this simply evaluates an expression for BOOL_TRUE/BOOL_FALSE and passes/fails as a result. Like all test functions it accepts a printf-style format and parameters to describe the test.<p>
<dl class="pre" compact><dt><b>Precondition:</b></dt><dd><ul>
<li><a class="el" href="group__lub__test.html#g47a56e695cab95b0c8140e677e8dafd0">lub_test_begin()</a> must have been called</li></ul>
</dd></dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A status code (LUB_TEST_PASS/LUB_TEST_FAIL)</dd></dl>
<dl class="post" compact><dt><b>Postcondition:</b></dt><dd><ul>
<li>The formatted scenario and result is reported in the logfile and/or stdout.</li><li>The test count is incremented by one.</li><li>If the tests fails then the overall unit-test status is changed to LUB_TEST_FAIL</li><li>If <a class="el" href="group__lub__test.html#g47a56e695cab95b0c8140e677e8dafd0">lub_test_begin()</a> has not been called the behaviour is undefined </li></ul>
</dd></dl>
<dl compact><dt><b>Parameters: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>expr</em>&nbsp;</td><td>
a boolean expression to evaluate </td></tr>
<tr><td valign="top"><em>fmt</em>&nbsp;</td><td>
a printf style format string to specify the test scenario </td></tr>
</table>
</dl>
</div>
</div><p>
<a class="anchor" name="g6dcf669c834d9a964a46f9d8d6d317bc"></a><!-- doxytag: member="test.h::lub_test_check_int" ref="g6dcf669c834d9a964a46f9d8d6d317bc" args="(int expect, int actual, const char *fmt,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__lub__test.html#g5cd77c431b404117a4559b252e8c8250">lub_test_status_t</a> lub_test_check_int           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>expect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>actual</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function is almost identical to test() except it accepts an exepcted and actual value to compares them. Equal values cause the test to pass, unequal cause the test to fail. Both values are recorded in the log output making it easier to understand failures.<p>
<dl class="pre" compact><dt><b>Precondition:</b></dt><dd><ul>
<li><a class="el" href="group__lub__test.html#g47a56e695cab95b0c8140e677e8dafd0">lub_test_begin()</a> must have been called</li></ul>
</dd></dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A status code (LUB_TEST_PASS/LUB_TEST_FAIL)</dd></dl>
<dl class="post" compact><dt><b>Postcondition:</b></dt><dd><ul>
<li>The formatted scenario and result is reported in the logfile and/or stdout.</li><li>The test count is incremented by one.</li><li>If the tests fails then the overall unit-test status is changed to LUB_TEST_FAIL</li><li>If <a class="el" href="group__lub__test.html#g47a56e695cab95b0c8140e677e8dafd0">lub_test_begin()</a> has not been called the behaviour is undefined </li></ul>
</dd></dl>
<dl compact><dt><b>Parameters: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>expect</em>&nbsp;</td><td>
the expected integer value </td></tr>
<tr><td valign="top"><em>actual</em>&nbsp;</td><td>
the actual integer value </td></tr>
<tr><td valign="top"><em>fmt</em>&nbsp;</td><td>
a printf style format string to specify the test scenario </td></tr>
</table>
</dl>
</div>
</div><p>
<a class="anchor" name="g3a53c9523f6ee52bfaa3627f15107599"></a><!-- doxytag: member="test.h::lub_test_end" ref="g3a53c9523f6ee52bfaa3627f15107599" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lub_test_end           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function ends the unit-test and closes the log file.<p>
<dl class="pre" compact><dt><b>Precondition:</b></dt><dd><ul>
<li><a class="el" href="group__lub__test.html#g47a56e695cab95b0c8140e677e8dafd0">lub_test_begin()</a> must have been called.</li><li><a class="el" href="group__lub__test.html#g3a53c9523f6ee52bfaa3627f15107599">lub_test_end()</a> must not have been called.</li></ul>
</dd></dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>none</dd></dl>
<dl class="post" compact><dt><b>Postcondition:</b></dt><dd><ul>
<li>The overall pass/fail status is reported to the log file and/or stdout.</li><li>The log file is closed.</li><li>If <a class="el" href="group__lub__test.html#g47a56e695cab95b0c8140e677e8dafd0">lub_test_begin()</a> has not been called then behaviour is undefined</li><li>If <a class="el" href="group__lub__test.html#g3a53c9523f6ee52bfaa3627f15107599">lub_test_end()</a> has been called the behaviour is undefined </li></ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="g1aeb2ab3f2f66d5b8ba9e40e08916a17"></a><!-- doxytag: member="test.h::lub_test_failure_count" ref="g1aeb2ab3f2f66d5b8ba9e40e08916a17" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int lub_test_failure_count           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The test utilities maintain internal counts for all the tests that have been performed since the unittest_begin() call. This function lets a client get the number of failures so far.<p>
<dl class="pre" compact><dt><b>Precondition:</b></dt><dd><ul>
<li><a class="el" href="group__lub__test.html#g47a56e695cab95b0c8140e677e8dafd0">lub_test_begin()</a> must have been called.</li><li><a class="el" href="group__lub__test.html#g3a53c9523f6ee52bfaa3627f15107599">lub_test_end()</a> must not have been called.</li></ul>
</dd></dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The current number of failed tests.</dd></dl>
<dl class="post" compact><dt><b>Postcondition:</b></dt><dd><ul>
<li>If <a class="el" href="group__lub__test.html#g47a56e695cab95b0c8140e677e8dafd0">lub_test_begin()</a> has not been called then behaviour is undefined</li><li>If <a class="el" href="group__lub__test.html#g3a53c9523f6ee52bfaa3627f15107599">lub_test_end()</a> has been called the behaviour is undefined </li></ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="gaa554b70566e82894b07e7f5a1c2fd3f"></a><!-- doxytag: member="test.h::lub_test_get_status" ref="gaa554b70566e82894b07e7f5a1c2fd3f" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__lub__test.html#g5cd77c431b404117a4559b252e8c8250">lub_test_status_t</a> lub_test_get_status           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function provide the current overall status for the unit-test. If any tests have failed then the unit-test is deemed to have failed.<p>
<dl class="pre" compact><dt><b>Precondition:</b></dt><dd><ul>
<li><a class="el" href="group__lub__test.html#g47a56e695cab95b0c8140e677e8dafd0">lub_test_begin()</a> must have been called.</li><li><a class="el" href="group__lub__test.html#g3a53c9523f6ee52bfaa3627f15107599">lub_test_end()</a> must not have been called.</li></ul>
</dd></dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The current overall status. (TESTPASS/TESTFAIL)</dd></dl>
<dl class="post" compact><dt><b>Postcondition:</b></dt><dd><ul>
<li>If <a class="el" href="group__lub__test.html#g47a56e695cab95b0c8140e677e8dafd0">lub_test_begin()</a> has not been called then behaviour is undefined</li><li>If <a class="el" href="group__lub__test.html#g3a53c9523f6ee52bfaa3627f15107599">lub_test_end()</a> has been called the behaviour is undefined </li></ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="gf5e98e92393bc3cfed4ae1300196fa47"></a><!-- doxytag: member="test.h::lub_test_log" ref="gf5e98e92393bc3cfed4ae1300196fa47" args="(lub_test_verbosity_t level, const char *fmt,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lub_test_log           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__lub__test.html#g3ca4834aa313ca4b054f4ef42973f30b">lub_test_verbosity_t</a>&nbsp;</td>
          <td class="paramname"> <em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This is the most generic of the logging functions. No addition formating is performed.<p>
<dl class="pre" compact><dt><b>Precondition:</b></dt><dd><ul>
<li><a class="el" href="group__lub__test.html#g47a56e695cab95b0c8140e677e8dafd0">lub_test_begin()</a> must have been called.</li><li><a class="el" href="group__lub__test.html#g3a53c9523f6ee52bfaa3627f15107599">lub_test_end()</a> must not have been called.</li></ul>
</dd></dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>none</dd></dl>
<dl class="post" compact><dt><b>Postcondition:</b></dt><dd><ul>
<li>If the specified verbosity is higher than that specified on the command line then the message will not be logged to the logfile and/or stdout.</li><li>If <a class="el" href="group__lub__test.html#g47a56e695cab95b0c8140e677e8dafd0">lub_test_begin()</a> has not been called then behaviour is undefined </li></ul>
</dd></dl>
<dl compact><dt><b>Parameters: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>level</em>&nbsp;</td><td>
the verbosity level for this message </td></tr>
<tr><td valign="top"><em>fmt</em>&nbsp;</td><td>
a printf style format string to specify the message to log </td></tr>
</table>
</dl>
</div>
</div><p>
<a class="anchor" name="gcc91ccd7ddbe72414bff9628d70cfda1"></a><!-- doxytag: member="test.h::lub_test_parse_command_line" ref="gcc91ccd7ddbe72414bff9628d70cfda1" args="(int argc, const char *const *argv)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lub_test_parse_command_line           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const *&nbsp;</td>
          <td class="paramname"> <em>argv</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function is responsible for parsing all the command line options, setting run time variables, and opening a log file if necessary.<p>
<dl class="user" compact><dt><b>Supported Command Line Switches:</b></dt><dd><em> Set the Verbosity level </em> <ul>
<li>-terse </li>
<li>-normal (default) </li>
<li>-verbose</li>
</ul>
<em> Set behaviour upon failure </em> <ul>
<li>-stoponfail </li>
<li>-continueonfail (default)</li>
</ul>
<em> Logging:</em></dd></dl>
Enable and disable logging to stdout <ul>
<li>-stdout (default) </li>
<li>-nostdout</li>
</ul>
Log to file named FILENAME (if no filename is specified "test.log" is used), or disable logging to a file <ul>
<li>-logfile [FILENAME] (default) </li>
<li>-nologfile</li>
</ul>
<em> Prints usage message and exit </em> -usage -help<p>
<dl class="pre" compact><dt><b>Precondition:</b></dt><dd>Must be the first unitTest function called.</dd></dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>none</dd></dl>
<dl class="post" compact><dt><b>Postcondition:</b></dt><dd>If there are conflicting command line options it will exit(1)</dd></dl>
If the log file cannot be opened it will exit(1) <dl compact><dt><b>Parameters: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>argc</em>&nbsp;</td><td>
The number of command line arguments </td></tr>
<tr><td valign="top"><em>argv</em>&nbsp;</td><td>
An array of command line arguments </td></tr>
</table>
</dl>
</div>
</div><p>
<a class="anchor" name="gb8d7f63c4c76e413338d8f662be7965d"></a><!-- doxytag: member="test.h::lub_test_seq_begin" ref="gb8d7f63c4c76e413338d8f662be7965d" args="(int seq, const char *fmt,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lub_test_seq_begin           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>seq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function starts a new test sequence.<p>
<dl class="pre" compact><dt><b>Precondition:</b></dt><dd><ul>
<li><a class="el" href="group__lub__test.html#g47a56e695cab95b0c8140e677e8dafd0">lub_test_begin()</a> must have been called.</li><li><a class="el" href="group__lub__test.html#g3a53c9523f6ee52bfaa3627f15107599">lub_test_end()</a> must not have been called.</li></ul>
</dd></dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>none</dd></dl>
<dl class="post" compact><dt><b>Postcondition:</b></dt><dd><ul>
<li>The test count is reset to zero.</li><li>The current sequence number and description is updated.</li><li>The begining of the sequence is reported in the logfile and/or stdout.</li><li>If <a class="el" href="group__lub__test.html#g47a56e695cab95b0c8140e677e8dafd0">lub_test_begin()</a> has not been called the behaviour is undefined</li><li>If <a class="el" href="group__lub__test.html#g3a53c9523f6ee52bfaa3627f15107599">lub_test_end()</a> has been called the behaviour is undefined </li></ul>
</dd></dl>
<dl compact><dt><b>Parameters: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>seq</em>&nbsp;</td><td>
a user specified sequence number </td></tr>
<tr><td valign="top"><em>fmt</em>&nbsp;</td><td>
a printf style format string to specify the sequence name </td></tr>
</table>
</dl>
</div>
</div><p>
<a class="anchor" name="g43608907f091e6f0b120db1907d25e0a"></a><!-- doxytag: member="test.h::lub_test_seq_end" ref="g43608907f091e6f0b120db1907d25e0a" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lub_test_seq_end           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function marks the end of the current sequence.<p>
<dl class="pre" compact><dt><b>Precondition:</b></dt><dd><ul>
<li><a class="el" href="group__lub__test.html#gb8d7f63c4c76e413338d8f662be7965d">lub_test_seq_begin()</a> must have been called.</li></ul>
</dd></dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>none</dd></dl>
<dl class="post" compact><dt><b>Postcondition:</b></dt><dd><ul>
<li>An end of sequence message is reported to the log file and/or stdout.</li><li>The current sequence number and description remains unchanged until the next call to unittest_seq_begin()</li><li>If <a class="el" href="group__lub__test.html#gb8d7f63c4c76e413338d8f662be7965d">lub_test_seq_begin()</a> has not been called then behaviour is undefined </li></ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="gbae5fe10a0b054fc352def00b142c772"></a><!-- doxytag: member="test.h::lub_test_seq_log" ref="gbae5fe10a0b054fc352def00b142c772" args="(lub_test_verbosity_t level, const char *fmt,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lub_test_seq_log           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__lub__test.html#g3ca4834aa313ca4b054f4ef42973f30b">lub_test_verbosity_t</a>&nbsp;</td>
          <td class="paramname"> <em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This is a good general purpose logging function. It parameters are the same as unittest_log, but this will log the provided information with the current sequence number, properly indented to provide nicely formatted output within a test.<p>
<dl class="pre" compact><dt><b>Precondition:</b></dt><dd><ul>
<li><a class="el" href="group__lub__test.html#gb8d7f63c4c76e413338d8f662be7965d">lub_test_seq_begin()</a> must have been called.</li></ul>
</dd></dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>none</dd></dl>
<dl class="post" compact><dt><b>Postcondition:</b></dt><dd><ul>
<li>The formatted message is reported in the logfile and/or stdout.</li><li>If <a class="el" href="group__lub__test.html#gb8d7f63c4c76e413338d8f662be7965d">lub_test_seq_begin()</a> has not been called the behaviour is undefined </li></ul>
</dd></dl>
<dl compact><dt><b>Parameters: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>level</em>&nbsp;</td><td>
The verbosity level of the message </td></tr>
<tr><td valign="top"><em>fmt</em>&nbsp;</td><td>
a printf style format string to specify the message </td></tr>
</table>
</dl>
</div>
</div><p>
<a class="anchor" name="g8e753db87b8c78b65c01279dd457c82b"></a><!-- doxytag: member="test.h::lub_test_stop_here" ref="g8e753db87b8c78b65c01279dd457c82b" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lub_test_stop_here           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function is provided as a DEBUG aid. A breakpoint set on this function will be reached everytime a test fails, with the failure case in context.<p>
<dl class="pre" compact><dt><b>Precondition:</b></dt><dd>none</dd></dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>none</dd></dl>
<dl class="post" compact><dt><b>Postcondition:</b></dt><dd>none </dd></dl>

</div>
</div><p>
<hr size="1"><address style="align: right;"><small>Generated on Tue Apr 29 13:41:09 2008 for CLISH by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.1 </small></address>
</body>
</html>
