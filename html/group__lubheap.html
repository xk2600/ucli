<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>CLISH: &quot;Little Useful Bits Heap&quot; Library</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.1 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="dirs.html"><span>Directories</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<h1>"Little Useful Bits Heap" Library</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
</table>
<h2><a class="anchor" name="Overview">
Overview</a></h2>
This library can be linked with executables to override the standard memory management provided by the system libraries. This may provide a performance and debugging advantage.<p>
The implementation uses the <a class="el" href="group__lub__heap.html">heap</a> component to control system memory and hence provides all the features available within that memory manager. (including leak detection)<h2><a class="anchor" name="VxWorks">
VxWorks</a></h2>
Replaces the memPartLib.o, memLib.o and memShow.o found in the libos.a library archive.<h3><a class="anchor" name="memlib">
memLib.o functions</a></h3>
<code> calloc, cfree, memFindMax, memInit, memLibInit, memOptionsSet, memPartFindMax, memPartOptionsSet, memPartRealloc, memalign, realloc, valloc </code><h3><a class="anchor" name="mempartlib">
memPartLib.o functions</a></h3>
<code> free, malloc, memAddToPool, memPartAddToPool, memPartAlignedAlloc, memPartAlloc, memPartBlockIsValid, memPartCreate, memPartFree, memPartInit, memPartLibInit </code><h3><a class="anchor" name="memshow">
memShow.o functions</a></h3>
<code> memShow, memPartInfoGet, memParShow </code><h2><a class="anchor" name="posix">
POSIX</a></h2>
Replaces the dynamic memory functionality found in the libc.a library archive.<p>
This implementation relies on the sbrk() function to provide memory chunks to feed the standard heap.<h3><a class="anchor" name="Functions">
Functions</a></h3>
<code> calloc, cfree, free, malloc, memalign, realloc, valloc </code><h2><a class="anchor" name="Performance">
Performance</a></h2>
Running the unittests with this library provides the following comparisons on some test machines:<h2><a class="anchor" name="x86_64-unknown-linux-gnu">
x86_64-unknown-linux-gnu</a></h2>
<table border="1" cellspacing="3" cellpadding="3">
<tr>
<td><b>Native memory management</b> (<code>./test/mallocTest</code>) </td><td><b>lubheap memory management</b> (<code>./test/lubMallocTest</code>)  </td></tr>
<tr>
<td><pre>
    100 in          0 milliseconds
    200 in          0 milliseconds
    300 in          0 milliseconds
    400 in          0 milliseconds
    500 in          1 milliseconds
   1000 in          3 milliseconds
   2000 in          7 milliseconds
   3000 in         12 milliseconds
   4000 in         16 milliseconds
   5000 in         21 milliseconds
  10000 in         48 milliseconds
  15000 in         79 milliseconds
  20000 in        143 milliseconds
  25000 in        200 milliseconds
  30000 in        253 milliseconds
  35000 in        314 milliseconds
  40000 in        378 milliseconds
  45000 in        460 milliseconds
  50000 in        561 milliseconds
  60000 in        790 milliseconds
  70000 in       1036 milliseconds
  80000 in       1320 milliseconds
  90000 in       1653 milliseconds
 100000 in       2037 milliseconds
</pre>  </td><td><pre>
    100 in          0 milliseconds
    200 in          0 milliseconds
    300 in          0 milliseconds
    400 in          1 milliseconds
    500 in          1 milliseconds
   1000 in          3 milliseconds
   2000 in          6 milliseconds
   3000 in          9 milliseconds
   4000 in         11 milliseconds
   5000 in         13 milliseconds
  10000 in         37 milliseconds
  15000 in         49 milliseconds
  20000 in         61 milliseconds
  25000 in         75 milliseconds
  30000 in         89 milliseconds
  35000 in         99 milliseconds
  40000 in        113 milliseconds
  45000 in        125 milliseconds
  50000 in        138 milliseconds
  60000 in        177 milliseconds
  70000 in        203 milliseconds
  80000 in        228 milliseconds
  90000 in        254 milliseconds
 100000 in        277 milliseconds
</pre>   </td></tr>
</table>
<h2><a class="anchor" name="i686-pc-linux-gnu">
i686-pc-linux-gnu</a></h2>
<table border="1" cellspacing="3" cellpadding="3">
<tr>
<td><b>Native memory management</b> (<code>./test/mallocTest</code>) </td><td><b>lubheap memory management</b> (<code>./test/lubMallocTest</code>)  </td></tr>
<tr>
<td><pre>
    100 in          0 milliseconds
    200 in          0 milliseconds
    300 in          0 milliseconds
    400 in          1 milliseconds
    500 in          1 milliseconds
   1000 in          3 milliseconds
   2000 in          7 milliseconds
   3000 in         12 milliseconds
   4000 in         16 milliseconds
   5000 in         21 milliseconds
  10000 in         46 milliseconds
  15000 in         76 milliseconds
  20000 in        111 milliseconds
  25000 in        151 milliseconds
  30000 in        199 milliseconds
  35000 in        256 milliseconds
  40000 in        318 milliseconds
  45000 in        393 milliseconds
  50000 in        472 milliseconds
  60000 in        658 milliseconds
  70000 in        874 milliseconds
  80000 in       1121 milliseconds
  90000 in       1411 milliseconds
 100000 in       1745 milliseconds
</pre>  </td><td><pre>
    100 in          0 milliseconds
    200 in          0 milliseconds
    300 in          1 milliseconds
    400 in          1 milliseconds
    500 in          1 milliseconds
   1000 in          4 milliseconds
   2000 in          7 milliseconds
   3000 in         11 milliseconds
   4000 in         13 milliseconds
   5000 in         15 milliseconds
  10000 in         42 milliseconds
  15000 in         57 milliseconds
  20000 in         72 milliseconds
  25000 in         89 milliseconds
  30000 in        105 milliseconds
  35000 in        121 milliseconds
  40000 in        136 milliseconds
  45000 in        154 milliseconds
  50000 in        169 milliseconds
  60000 in        213 milliseconds
  70000 in        246 milliseconds
  80000 in        278 milliseconds
  90000 in        311 milliseconds
 100000 in        341 milliseconds
</pre>   </td></tr>
</table>
<h2><a class="anchor" name="i686-pc-cygwin">
i686-pc-cygwin</a></h2>
For some reason the native memory management under cygwin is quicker. My suspcion is that there is an overhead in the <code>sbrk()</code> call via the cygwin sub-system which slows the lubheap implementation... <table border="1" cellspacing="3" cellpadding="3">
<tr>
<td><b>Native memory management</b> (<code>./test/mallocTest</code>) </td><td><b>lubheap memory management</b> (<code>./test/lubMallocTest</code>)  </td></tr>
<tr>
<td><pre>
    100 in          0 milliseconds
    200 in          0 milliseconds
    300 in          0 milliseconds
    400 in          0 milliseconds
    500 in          0 milliseconds
   1000 in          0 milliseconds
   2000 in          0 milliseconds
   3000 in         16 milliseconds
   4000 in         15 milliseconds
   5000 in         16 milliseconds
  10000 in         31 milliseconds
  15000 in         47 milliseconds
  20000 in         63 milliseconds
  25000 in         93 milliseconds
  30000 in        125 milliseconds
  35000 in        204 milliseconds
  40000 in        203 milliseconds
  45000 in        218 milliseconds
  50000 in        266 milliseconds
  60000 in        328 milliseconds
  70000 in        360 milliseconds
  80000 in        406 milliseconds
  90000 in        500 milliseconds
 100000 in        515 milliseconds
</pre>  </td><td><pre>
    100 in          0 milliseconds
    200 in          0 milliseconds
    300 in          0 milliseconds
    400 in          0 milliseconds
    500 in         15 milliseconds
   1000 in          0 milliseconds
   2000 in         16 milliseconds
   3000 in         31 milliseconds
   4000 in         31 milliseconds
   5000 in         47 milliseconds
  10000 in         94 milliseconds
  15000 in        156 milliseconds
  20000 in        188 milliseconds
  25000 in        250 milliseconds
  30000 in        281 milliseconds
  35000 in        375 milliseconds
  40000 in        375 milliseconds
  45000 in        453 milliseconds
  50000 in        484 milliseconds
  60000 in        625 milliseconds
  70000 in        672 milliseconds
  80000 in        813 milliseconds
  90000 in        875 milliseconds
 100000 in        984 milliseconds
</pre>   </td></tr>
</table>
<hr size="1"><address style="align: right;"><small>Generated on Tue Apr 29 13:41:08 2008 for CLISH by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.1 </small></address>
</body>
</html>
