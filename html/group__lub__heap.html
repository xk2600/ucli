<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>CLISH: heap</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.1 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="dirs.html"><span>Directories</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<h1>heap<br>
<small>
[<a class="el" href="group__lub.html">&quot;Little Useful Bits&quot; Library</a>]</small>
</h1>This is a generic heap manager which incorporates a memory leak detection system which can monitor and report the dynamic memory which is in use for each heap.  
<a href="#_details">More...</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>lub_heap_stats_s</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>struct_void_ptr</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>_lub_partition_spec</b></td></tr>

<tr><td colspan="2"><br><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lub__heap.html#geb594b21cf15221b2a33d61093af07bb">LUB_HEAP_ZERO_ALLOC</a>&nbsp;&nbsp;&nbsp;((void*)-1)</td></tr>

<tr><td colspan="2"><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef lub_heap_s&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lub__heap.html#g129a7b63c896fb5058cbcbb865aee35a">lub_heap_t</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef lub_heap_free_block_s&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lub__heap.html#gcc8fe218321fc599c8b1a359d31f5c6a">lub_heap_free_block_t</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef lub_heap_stats_s&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lub__heap.html#g80ed67d3858c4e5783570afa6910e9c8">lub_heap_stats_t</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lub__heap.html#gddc3c39029814ce984a987e67293b3d9">lub_heap_foreach_fn</a> (void *block, unsigned index, size_t size, void *arg)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef _lub_partition&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lub__heap.html#g5ba9b552695e0934df61f2f1e0ec2d80">lub_partition_t</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef _lub_partition_spec&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lub__heap.html#g7d39531da84d325c30559c533724c938">lub_partition_spec_t</a></td></tr>

<tr><td colspan="2"><br><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lub__heap.html#gab49018edc28d9a3865814dab225ad20">lub_heap_status_t</a> { <br>
&nbsp;&nbsp;<a class="el" href="group__lub__heap.html#ggab49018edc28d9a3865814dab225ad208fb3cb26d3e20d3f99d058620d2f8c1e">LUB_HEAP_OK</a>, 
<a class="el" href="group__lub__heap.html#ggab49018edc28d9a3865814dab225ad20488734ebe3ac87a3f061cb1e9e160228">LUB_HEAP_FAILED</a>, 
<a class="el" href="group__lub__heap.html#ggab49018edc28d9a3865814dab225ad209d6bd8c3b878a23cc8477a771a1204a1">LUB_HEAP_DOUBLE_FREE</a>, 
<a class="el" href="group__lub__heap.html#ggab49018edc28d9a3865814dab225ad20a531672d67b6ca8e1d0e084ccb951e05">LUB_HEAP_CORRUPTED</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="group__lub__heap.html#ggab49018edc28d9a3865814dab225ad20750287dac5ad1bc96e94bd66c2b5f033">LUB_HEAP_INVALID_POINTER</a>
<br>
 }</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lub__heap.html#g4a9d7981e684056c93ec2fb8887f9736">lub_heap_align_t</a> { <br>
&nbsp;&nbsp;<a class="el" href="group__lub__heap.html#gg4a9d7981e684056c93ec2fb8887f97364bcdfd55bc38f6ad28349e2a594ddeb1">LUB_HEAP_ALIGN_NATIVE</a> =  sizeof(struct_void_ptr), 
<a class="el" href="group__lub__heap.html#gg4a9d7981e684056c93ec2fb8887f97367e6435dc0861657db4a9de3d61b45870">LUB_HEAP_ALIGN_2_POWER_2</a> =  0x00000004, 
<a class="el" href="group__lub__heap.html#gg4a9d7981e684056c93ec2fb8887f9736bdaa9b6b109908bc33070e85afc3a91a">LUB_HEAP_ALIGN_2_POWER_3</a> =  0x00000008, 
<a class="el" href="group__lub__heap.html#gg4a9d7981e684056c93ec2fb8887f97362b4a91a1326b84a38e92a853acd41632">LUB_HEAP_ALIGN_2_POWER_4</a> =  0x00000010, 
<br>
&nbsp;&nbsp;<a class="el" href="group__lub__heap.html#gg4a9d7981e684056c93ec2fb8887f973604d2a1a1100c2d450adff4122cea10a7">LUB_HEAP_ALIGN_2_POWER_5</a> =  0x00000020, 
<a class="el" href="group__lub__heap.html#gg4a9d7981e684056c93ec2fb8887f9736704482696b47542984d3ef2d8d8d76d3">LUB_HEAP_ALIGN_2_POWER_6</a> =  0x00000040, 
<a class="el" href="group__lub__heap.html#gg4a9d7981e684056c93ec2fb8887f9736ee7d76124087fe07cbef17c2f1862574">LUB_HEAP_ALIGN_2_POWER_7</a> =  0x00000080, 
<a class="el" href="group__lub__heap.html#gg4a9d7981e684056c93ec2fb8887f973657e131b1e4f988a56e11c45a41b35d7f">LUB_HEAP_ALIGN_2_POWER_8</a> =  0x00000100, 
<br>
&nbsp;&nbsp;<a class="el" href="group__lub__heap.html#gg4a9d7981e684056c93ec2fb8887f9736c7bb0e7133a6db470fef2a261f3bc846">LUB_HEAP_ALIGN_2_POWER_9</a> =  0x00000200, 
<a class="el" href="group__lub__heap.html#gg4a9d7981e684056c93ec2fb8887f97360dd3b4167c653e9fdcd9d21495eb245a">LUB_HEAP_ALIGN_2_POWER_10</a> =  0x00000400, 
<a class="el" href="group__lub__heap.html#gg4a9d7981e684056c93ec2fb8887f9736de1f122824b42b6d28571fe74a435de1">LUB_HEAP_ALIGN_2_POWER_11</a> =  0x00000800, 
<a class="el" href="group__lub__heap.html#gg4a9d7981e684056c93ec2fb8887f9736649650c61c604be76e7a7828e6bc1a7d">LUB_HEAP_ALIGN_2_POWER_12</a> =  0x00001000, 
<br>
&nbsp;&nbsp;<a class="el" href="group__lub__heap.html#gg4a9d7981e684056c93ec2fb8887f9736521e810c06ca710e30563cb6a72016d2">LUB_HEAP_ALIGN_2_POWER_13</a> =  0x00002000, 
<a class="el" href="group__lub__heap.html#gg4a9d7981e684056c93ec2fb8887f9736fa070e706f53410ef46cd0bfc4a1001a">LUB_HEAP_ALIGN_2_POWER_14</a> =  0x00004000, 
<a class="el" href="group__lub__heap.html#gg4a9d7981e684056c93ec2fb8887f97362eedf6aa5d2a7202cf00fd6a40c4e0b7">LUB_HEAP_ALIGN_2_POWER_15</a> =  0x00008000, 
<a class="el" href="group__lub__heap.html#gg4a9d7981e684056c93ec2fb8887f9736762f5b6e073085f7462427a8031d85aa">LUB_HEAP_ALIGN_2_POWER_16</a> =  0x00010000, 
<br>
&nbsp;&nbsp;<a class="el" href="group__lub__heap.html#gg4a9d7981e684056c93ec2fb8887f9736e009e682bf437fd1d33962453b9a801e">LUB_HEAP_ALIGN_2_POWER_17</a> =  0x00020000, 
<a class="el" href="group__lub__heap.html#gg4a9d7981e684056c93ec2fb8887f9736c48f0c2cd91c5cfab9621d032f5b3fe0">LUB_HEAP_ALIGN_2_POWER_18</a> =  0x00040000, 
<a class="el" href="group__lub__heap.html#gg4a9d7981e684056c93ec2fb8887f97368aea61b84276dd041b9283a20cd25195">LUB_HEAP_ALIGN_2_POWER_19</a> =  0x00080000, 
<a class="el" href="group__lub__heap.html#gg4a9d7981e684056c93ec2fb8887f973696ebbe8984583995e3127a7d4f432f14">LUB_HEAP_ALIGN_2_POWER_20</a> =  0x00100000, 
<br>
&nbsp;&nbsp;<a class="el" href="group__lub__heap.html#gg4a9d7981e684056c93ec2fb8887f97367edf625c4d38e98a49c570fcb2ad9132">LUB_HEAP_ALIGN_2_POWER_21</a> =  0x00200000, 
<a class="el" href="group__lub__heap.html#gg4a9d7981e684056c93ec2fb8887f973669c741dc10c45cdef99d9350ad99f6e5">LUB_HEAP_ALIGN_2_POWER_22</a> =  0x00400000, 
<a class="el" href="group__lub__heap.html#gg4a9d7981e684056c93ec2fb8887f9736f52a2a0d7b86c36a75f5e0e33027aca7">LUB_HEAP_ALIGN_2_POWER_23</a> =  0x00800000, 
<a class="el" href="group__lub__heap.html#gg4a9d7981e684056c93ec2fb8887f973665c146f467678cee5db554f8478c5a9f">LUB_HEAP_ALIGN_2_POWER_24</a> =  0x01000000, 
<br>
&nbsp;&nbsp;<a class="el" href="group__lub__heap.html#gg4a9d7981e684056c93ec2fb8887f973630e262cdf82aa7113ddc890a9bcfdcf2">LUB_HEAP_ALIGN_2_POWER_25</a> =  0x02000000, 
<a class="el" href="group__lub__heap.html#gg4a9d7981e684056c93ec2fb8887f973661a4f8875f89e580b58a50f79bb5ecc4">LUB_HEAP_ALIGN_2_POWER_26</a> =  0x04000000, 
<a class="el" href="group__lub__heap.html#gg4a9d7981e684056c93ec2fb8887f9736c54203466584902578833230af7583f3">LUB_HEAP_ALIGN_2_POWER_27</a> =  0x08000000
<br>
 }</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lub__heap.html#gd4f0a8d6bc7b9f089520e9a7306ea071">lub_heap_show_e</a> { <a class="el" href="group__lub__heap.html#ggd4f0a8d6bc7b9f089520e9a7306ea0716ff186db1ca8cb6163cdac53566ebd47">LUB_HEAP_SHOW_LEAKS</a>, 
<a class="el" href="group__lub__heap.html#ggd4f0a8d6bc7b9f089520e9a7306ea071eab056b0f57ef0562fc9b5a8ddf8cf44">LUB_HEAP_SHOW_PARTIALS</a>, 
<a class="el" href="group__lub__heap.html#ggd4f0a8d6bc7b9f089520e9a7306ea071b9fc60896b467c4b220c1cfe75e721fc">LUB_HEAP_SHOW_ALL</a>
 }</td></tr>

<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lub__heap.html#g36ab69b85984b310c774be3cfde95e02">lub_heap_foreach_segment</a> (<a class="el" href="group__lub__heap.html#g129a7b63c896fb5058cbcbb865aee35a">lub_heap_t</a> *instance, <a class="el" href="group__lub__heap.html#gddc3c39029814ce984a987e67293b3d9">lub_heap_foreach_fn</a> *fn, void *arg)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lub__heap.html#gc00dba6172ae3b6c3084fd22fbd20d20">lub_heap_foreach_free_block</a> (<a class="el" href="group__lub__heap.html#g129a7b63c896fb5058cbcbb865aee35a">lub_heap_t</a> *instance, <a class="el" href="group__lub__heap.html#gddc3c39029814ce984a987e67293b3d9">lub_heap_foreach_fn</a> *fn, void *arg)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__lub__heap.html#g129a7b63c896fb5058cbcbb865aee35a">lub_heap_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lub__heap.html#ge725109644e18f395eecc922b1bffa20">lub_heap_create</a> (void *start, size_t size)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lub__heap.html#g17abaa12fe023d24618ca9cff747f009">lub_heap_destroy</a> (<a class="el" href="group__lub__heap.html#g129a7b63c896fb5058cbcbb865aee35a">lub_heap_t</a> *instance)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lub__heap.html#g414a3c52b7b7169ac66f84d8a0878549">lub_heap_add_segment</a> (<a class="el" href="group__lub__heap.html#g129a7b63c896fb5058cbcbb865aee35a">lub_heap_t</a> *instance, void *start, size_t size)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lub__heap.html#g90b9231dfa57d8846cc821b58d5625d5">lub_heap_static_alloc</a> (<a class="el" href="group__lub__heap.html#g129a7b63c896fb5058cbcbb865aee35a">lub_heap_t</a> *instance, size_t size)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__lub__heap.html#gab49018edc28d9a3865814dab225ad20">lub_heap_status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lub__heap.html#g46a1d39d0d3661a4698ce0d3ac838856">lub_heap_realloc</a> (<a class="el" href="group__lub__heap.html#g129a7b63c896fb5058cbcbb865aee35a">lub_heap_t</a> *instance, char **ptr, size_t size, <a class="el" href="group__lub__heap.html#g4a9d7981e684056c93ec2fb8887f9736">lub_heap_align_t</a> alignment)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__lub__types.html#g04dd5074964518403bf944f2b240a5f8">bool_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lub__heap.html#g477f92c6ee9e1195dcdd1e915fc6b4fd">lub_heap_taint</a> (<a class="el" href="group__lub__types.html#g04dd5074964518403bf944f2b240a5f8">bool_t</a> enable)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__lub__types.html#g04dd5074964518403bf944f2b240a5f8">bool_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lub__heap.html#g16f1fd880a804c6eb2aec9a78f871565">lub_heap_is_tainting</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__lub__types.html#g04dd5074964518403bf944f2b240a5f8">bool_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lub__heap.html#g1afa70ccf5e601fe5adc291475e9784c">lub_heap_check</a> (<a class="el" href="group__lub__types.html#g04dd5074964518403bf944f2b240a5f8">bool_t</a> enable)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__lub__types.html#g04dd5074964518403bf944f2b240a5f8">bool_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lub__heap.html#g60c64a44f73c23d79922f5791a2a1c40">lub_heap_is_checking</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__lub__types.html#g04dd5074964518403bf944f2b240a5f8">bool_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lub__heap.html#g964ec29df1b3474a8bf08771c8f824dd">lub_heap_check_memory</a> (<a class="el" href="group__lub__heap.html#g129a7b63c896fb5058cbcbb865aee35a">lub_heap_t</a> *instance)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lub__heap.html#gc7aad687710900748aa05874abf1dfbf">lub_heap_stop_here</a> (<a class="el" href="group__lub__heap.html#gab49018edc28d9a3865814dab225ad20">lub_heap_status_t</a> status, char *old_ptr, size_t new_size)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lub__heap.html#g3f01e771ee399c463a0cccb3c03965e8">lub_heap__get_stats</a> (<a class="el" href="group__lub__heap.html#g129a7b63c896fb5058cbcbb865aee35a">lub_heap_t</a> *instance, <a class="el" href="group__lub__heap.html#g80ed67d3858c4e5783570afa6910e9c8">lub_heap_stats_t</a> *stats)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lub__heap.html#g9d0e743dc5ea4c92d5ad46a337b9bb29">lub_heap_show</a> (<a class="el" href="group__lub__heap.html#g129a7b63c896fb5058cbcbb865aee35a">lub_heap_t</a> *instance, <a class="el" href="group__lub__types.html#g04dd5074964518403bf944f2b240a5f8">bool_t</a> verbose)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lub__heap.html#g39480d0aba862821dde07cfcc1fd8ed3">lub_heap__get_max_free</a> (<a class="el" href="group__lub__heap.html#g129a7b63c896fb5058cbcbb865aee35a">lub_heap_t</a> *instance)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g2123ea68cc5614043dd011fca45b02b1"></a><!-- doxytag: member="lub_heap::lub_heap__get_block_overhead" ref="g2123ea68cc5614043dd011fca45b02b1" args="(lub_heap_t *instance, const void *ptr)" -->
size_t&nbsp;</td><td class="memItemRight" valign="bottom"><b>lub_heap__get_block_overhead</b> (<a class="el" href="group__lub__heap.html#g129a7b63c896fb5058cbcbb865aee35a">lub_heap_t</a> *instance, const void *ptr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g3876fb9b5c7866fb3d9c3f662c461ca4"></a><!-- doxytag: member="lub_heap::lub_heap__get_block_size" ref="g3876fb9b5c7866fb3d9c3f662c461ca4" args="(lub_heap_t *instance, const void *ptr)" -->
size_t&nbsp;</td><td class="memItemRight" valign="bottom"><b>lub_heap__get_block_size</b> (<a class="el" href="group__lub__heap.html#g129a7b63c896fb5058cbcbb865aee35a">lub_heap_t</a> *instance, const void *ptr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lub__heap.html#g20d60ba7e27ab34023515c22a9f0a6c1">lub_heap_leak_scan</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__lub__types.html#g04dd5074964518403bf944f2b240a5f8">bool_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lub__heap.html#g27ea180a1810ac93058965062e6e9bfa">lub_heap_leak_report</a> (<a class="el" href="group__lub__heap.html#gd4f0a8d6bc7b9f089520e9a7306ea071">lub_heap_show_e</a> how, const char *substring)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lub__heap.html#g5d43fb90d77f185f6cb9d012ae5074a5">lub_heap__set_framecount</a> (unsigned framecount)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="gb8e7c4e732e4521d34eff09d2c8218a1"></a><!-- doxytag: member="lub_heap::lub_heap__get_framecount" ref="gb8e7c4e732e4521d34eff09d2c8218a1" args="(void)" -->
unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><b>lub_heap__get_framecount</b> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g46dc3f9dacae9830ec0aac92cc510263"></a><!-- doxytag: member="lub_heap::lub_heap_validate_pointer" ref="g46dc3f9dacae9830ec0aac92cc510263" args="(lub_heap_t *instance, char *ptr)" -->
<a class="el" href="group__lub__types.html#g04dd5074964518403bf944f2b240a5f8">bool_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>lub_heap_validate_pointer</b> (<a class="el" href="group__lub__heap.html#g129a7b63c896fb5058cbcbb865aee35a">lub_heap_t</a> *instance, char *ptr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lub__heap.html#g93612fe6821dedb10b7347f6a6b78193">lub_heap_init</a> (const char *program_name)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__lub__heap.html#gab49018edc28d9a3865814dab225ad20">lub_heap_status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lub__heap.html#gca4e146e51b8ba1a2cc61a739a66ad83">lub_heap_cache_init</a> (<a class="el" href="group__lub__heap.html#g129a7b63c896fb5058cbcbb865aee35a">lub_heap_t</a> *instance, <a class="el" href="group__lub__heap.html#g4a9d7981e684056c93ec2fb8887f9736">lub_heap_align_t</a> max_block_size, size_t num_max_blocks)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lub__heap.html#g42d6914ff2ae2ab8f57e4b91dc8b9f0b">lub_heap_leak_suppress_detection</a> (<a class="el" href="group__lub__heap.html#g129a7b63c896fb5058cbcbb865aee35a">lub_heap_t</a> *instance)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lub__heap.html#gdc7dc0b4ef07595e2a07c0a4d6f982b6">lub_heap_leak_restore_detection</a> (<a class="el" href="group__lub__heap.html#g129a7b63c896fb5058cbcbb865aee35a">lub_heap_t</a> *instance)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lub__heap.html#gde5f3d9dbc7c208b6896e3e7f49b204a">lub_heap_overhead_size</a> (<a class="el" href="group__lub__heap.html#g4a9d7981e684056c93ec2fb8887f9736">lub_heap_align_t</a> max_block_size, size_t num_max_blocks)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__lub__heap.html#g5ba9b552695e0934df61f2f1e0ec2d80">lub_partition_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lub__heap.html#g5a8b738751f94f68f3177c9ec63df4ad">lub_partition_create</a> (const <a class="el" href="group__lub__heap.html#g7d39531da84d325c30559c533724c938">lub_partition_spec_t</a> *spec)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lub__heap.html#g1bed2bfd16e60ffe42da7e0a6c3d11d3">lub_partition_kill</a> (<a class="el" href="group__lub__heap.html#g5ba9b552695e0934df61f2f1e0ec2d80">lub_partition_t</a> *instance)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__lub__heap.html#gab49018edc28d9a3865814dab225ad20">lub_heap_status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lub__heap.html#g8683176aa50668eb765ab17c421cc5d8">lub_partition_realloc</a> (<a class="el" href="group__lub__heap.html#g5ba9b552695e0934df61f2f1e0ec2d80">lub_partition_t</a> *instance, char **ptr, size_t size, <a class="el" href="group__lub__heap.html#g4a9d7981e684056c93ec2fb8887f9736">lub_heap_align_t</a> alignment)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__lub__types.html#g04dd5074964518403bf944f2b240a5f8">bool_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lub__heap.html#gd83809882c37206aaed3f1f3ddb9d4dd">lub_partition_check_memory</a> (<a class="el" href="group__lub__heap.html#g5ba9b552695e0934df61f2f1e0ec2d80">lub_partition_t</a> *instance)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lub__heap.html#g98c3c0f4e14c47ff7e0b1b1c93027203">lub_partition_show</a> (<a class="el" href="group__lub__heap.html#g5ba9b552695e0934df61f2f1e0ec2d80">lub_partition_t</a> *instance, <a class="el" href="group__lub__types.html#g04dd5074964518403bf944f2b240a5f8">bool_t</a> verbose)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lub__heap.html#g98a8a9e389f033b1ba2a47cf1c9c173d">lub_partition_stop_here</a> (<a class="el" href="group__lub__heap.html#gab49018edc28d9a3865814dab225ad20">lub_heap_status_t</a> status, char *old_ptr, size_t new_size)</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
This is a generic heap manager which incorporates a memory leak detection system which can monitor and report the dynamic memory which is in use for each heap. 
<p>
A client creates an instance of heap; providing it with memory segments to manage. Subsequent operations can then be invoked to obtain memory from those registered segments.<h2><a class="anchor" name="static_allocs">
Static allocation</a></h2>
Static memory allocations are those which are for the lifetime of the heap from which they are allocated. Because they do not need to be freed there is zero overhead required for such blocks; they can be exactly butted up against each other in memory. There is also zero fragmentation as they are never freed.<h2><a class="anchor" name="dynamic_allocs">
Dynamic allocation</a></h2>
Dynamic memory allocations have a lifetime less than that of the heap from which they are allocated. In order to manage the reuse of this blocks once they are released, there will be a slight "housekeeping" overhead associated with each block. They are also suceptible to fragmentation, which can occur when the lifetimes of blocks differ from one another.<h2><a class="anchor" name="leak_detection">
Leak Detection</a></h2>
It monitors the dynamic allocation which are performed and maintains statistics to help identify and isolation memory leaks.<p>
It detects two types of leak by scanning the BSS and DATA segments and identifying any nodes referenced from there. Then each of these referenced nodes is scanned to look for further references.<h3><a class="anchor" name="full_leak">
Full Leak</a></h3>
there is no reference to a block of memory or to any memory within that block in the system.<h3><a class="anchor" name="partial_leak">
Partial Leak</a></h3>
there is no reference to the start of a block of memory. NB. there may be circumstances where this is not a real leak, e.g. memory allocation systems typically hand out references just beyond a control header to their clients. However there may also be instances where this is a real leak and someone just happens to have a reference to some contained data.<h2><a class="anchor" name="tainting">
Memory Tainting</a></h2>
Memory is deliberately dirtied in the following ways:<p>
<ul>
<li>Initial heap space - 0xBBBBBBBB</li><li>Allocated memory - 0xAAAAAAAA</li><li>Freed memory - 0xFFFFFFFF</li><li>Dead Stack memory - 0xCCCCCCCC (done before leak scan)</li></ul>
<h2><a class="anchor" name="usage">
Utility functions</a></h2>
Currently the following utility functions are available:<p>
<ul>
<li>leakScan [0|1|2] - provides a dump of the currently allocated blocks of memory in the system pool. argument values have the following meanings:<ul>
<li>0 - display stats for just memory leaks.</li><li>1 - display stats for memory leaks and partial leaks.</li><li>2 - display stats for all currently allocation memory blocks.</li></ul>
</li></ul>
<p>
<ul>
<li>leakEnable [framecount] - enables leak detection and causes the current statistics to be cleared out. Even if there are memory blocks in use, this command will cause future "leakShow" invocations to behave as if monitoring started from this new point in time. The optional 'framecount' argument can be used to change the number of levels of backtrace recorded. By default this number is 16. The number of contexts stored will be affected by this number. If the value is small then a limited number of contexts will exist and the memory overhead of monitoring will be reduced. If the number is large (can support a maximum of 16 levels) then the granularity of the contexts will be finer i.e. more of them, but the memory overhead in monitoring will be increased. With no specified framecount the maximum will be assumed.</li></ul>
<p>
<ul>
<li>leakDisable - Disabled the leak detection.</li></ul>
<h2><a class="anchor" name="implementation">
Implementation</a></h2>
Static and dynamic blocks are allocated from opposite ends of a memory segment. As static blocks are allocated the end of the last "free block" migrates downwards in memory. Dynamic blocks are allocated from the start of the appropriately sized free block, hence leaving space for static allocations at the end of the heap memory.<p>
The heap implements a "best fit" model, for allocation of dynamic memory. This means that free blocks are maintained in size order and hence the most appropriate one can be used to satisfy client requests. This minimises fragmentation of the dynamically allocated memory.<p>
The free blocks are held in a binary tree (using <a class="el" href="group__lub__bintree.html">bintree</a>) which provide fast searching for the appropriate block.<p>
<dl class="author" compact><dt><b>Author:</b></dt><dd>Graeme McKerrell </dd></dl>
<dl class="date" compact><dt><b>Date:</b></dt><dd>Created On : Wed Dec 14 10:20:00 2005 </dd></dl>
<dl class="version" compact><dt><b>Version:</b></dt><dd>UNTESTED </dd></dl>
<hr><h2>Define Documentation</h2>
<a class="anchor" name="geb594b21cf15221b2a33d61093af07bb"></a><!-- doxytag: member="heap.h::LUB_HEAP_ZERO_ALLOC" ref="geb594b21cf15221b2a33d61093af07bb" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LUB_HEAP_ZERO_ALLOC&nbsp;&nbsp;&nbsp;((void*)-1)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This 'magic' pointer is returned when a client requests zero bytes The client can see that the allocation has succeeded, but cannot use the "memory" returned. This pointer may be passed transparently back to <a class="el" href="group__lub__heap.html#g46a1d39d0d3661a4698ce0d3ac838856">lub_heap_realloc()</a> without impact. 
</div>
</div><p>
<hr><h2>Typedef Documentation</h2>
<a class="anchor" name="gddc3c39029814ce984a987e67293b3d9"></a><!-- doxytag: member="heap.h::lub_heap_foreach_fn" ref="gddc3c39029814ce984a987e67293b3d9" args="(void *block, unsigned index, size_t size, void *arg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void <a class="el" href="group__lub__heap.html#gddc3c39029814ce984a987e67293b3d9">lub_heap_foreach_fn</a>(void *block,unsigned index,size_t size,void *arg)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This type defines a function prototype to be used to iterate around each of a number of things in the system. 
</div>
</div><p>
<a class="anchor" name="gcc8fe218321fc599c8b1a359d31f5c6a"></a><!-- doxytag: member="heap.h::lub_heap_free_block_t" ref="gcc8fe218321fc599c8b1a359d31f5c6a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct lub_heap_free_block_s <a class="el" href="group__lub__heap.html#gcc8fe218321fc599c8b1a359d31f5c6a">lub_heap_free_block_t</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This type is used to reference an instance of a free block 
</div>
</div><p>
<a class="anchor" name="g80ed67d3858c4e5783570afa6910e9c8"></a><!-- doxytag: member="heap.h::lub_heap_stats_t" ref="g80ed67d3858c4e5783570afa6910e9c8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct lub_heap_stats_s <a class="el" href="group__lub__heap.html#g80ed67d3858c4e5783570afa6910e9c8">lub_heap_stats_t</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This type defines the statistics available for each heap. 
</div>
</div><p>
<a class="anchor" name="g129a7b63c896fb5058cbcbb865aee35a"></a><!-- doxytag: member="heap.h::lub_heap_t" ref="g129a7b63c896fb5058cbcbb865aee35a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct lub_heap_s <a class="el" href="group__lub__heap.html#g129a7b63c896fb5058cbcbb865aee35a">lub_heap_t</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This type is used to reference an instance of a heap. 
</div>
</div><p>
<a class="anchor" name="g7d39531da84d325c30559c533724c938"></a><!-- doxytag: member="partition.h::lub_partition_spec_t" ref="g7d39531da84d325c30559c533724c938" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct _lub_partition_spec <a class="el" href="group__lub__heap.html#g7d39531da84d325c30559c533724c938">lub_partition_spec_t</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This type is used to specify any local_ requirements 
</div>
</div><p>
<a class="anchor" name="g5ba9b552695e0934df61f2f1e0ec2d80"></a><!-- doxytag: member="partition.h::lub_partition_t" ref="g5ba9b552695e0934df61f2f1e0ec2d80" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct _lub_partition <a class="el" href="group__lub__heap.html#g5ba9b552695e0934df61f2f1e0ec2d80">lub_partition_t</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This type is used to reference an instance of a heap. 
</div>
</div><p>
<hr><h2>Enumeration Type Documentation</h2>
<a class="anchor" name="g4a9d7981e684056c93ec2fb8887f9736"></a><!-- doxytag: member="heap.h::lub_heap_align_t" ref="g4a9d7981e684056c93ec2fb8887f9736" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__lub__heap.html#g4a9d7981e684056c93ec2fb8887f9736">lub_heap_align_t</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This type is used to indicate the alignment required for a memory allocation. <dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="gg4a9d7981e684056c93ec2fb8887f97364bcdfd55bc38f6ad28349e2a594ddeb1"></a><!-- doxytag: member="LUB_HEAP_ALIGN_NATIVE" ref="gg4a9d7981e684056c93ec2fb8887f97364bcdfd55bc38f6ad28349e2a594ddeb1" args="" -->LUB_HEAP_ALIGN_NATIVE</em>&nbsp;</td><td>
This is the "native" alignment required for the current CPU architecture. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg4a9d7981e684056c93ec2fb8887f97367e6435dc0861657db4a9de3d61b45870"></a><!-- doxytag: member="LUB_HEAP_ALIGN_2_POWER_2" ref="gg4a9d7981e684056c93ec2fb8887f97367e6435dc0861657db4a9de3d61b45870" args="" -->LUB_HEAP_ALIGN_2_POWER_2</em>&nbsp;</td><td>
4 byte alignment </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg4a9d7981e684056c93ec2fb8887f9736bdaa9b6b109908bc33070e85afc3a91a"></a><!-- doxytag: member="LUB_HEAP_ALIGN_2_POWER_3" ref="gg4a9d7981e684056c93ec2fb8887f9736bdaa9b6b109908bc33070e85afc3a91a" args="" -->LUB_HEAP_ALIGN_2_POWER_3</em>&nbsp;</td><td>
8 byte alignment </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg4a9d7981e684056c93ec2fb8887f97362b4a91a1326b84a38e92a853acd41632"></a><!-- doxytag: member="LUB_HEAP_ALIGN_2_POWER_4" ref="gg4a9d7981e684056c93ec2fb8887f97362b4a91a1326b84a38e92a853acd41632" args="" -->LUB_HEAP_ALIGN_2_POWER_4</em>&nbsp;</td><td>
16 byte alignment </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg4a9d7981e684056c93ec2fb8887f973604d2a1a1100c2d450adff4122cea10a7"></a><!-- doxytag: member="LUB_HEAP_ALIGN_2_POWER_5" ref="gg4a9d7981e684056c93ec2fb8887f973604d2a1a1100c2d450adff4122cea10a7" args="" -->LUB_HEAP_ALIGN_2_POWER_5</em>&nbsp;</td><td>
32 byte alignment </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg4a9d7981e684056c93ec2fb8887f9736704482696b47542984d3ef2d8d8d76d3"></a><!-- doxytag: member="LUB_HEAP_ALIGN_2_POWER_6" ref="gg4a9d7981e684056c93ec2fb8887f9736704482696b47542984d3ef2d8d8d76d3" args="" -->LUB_HEAP_ALIGN_2_POWER_6</em>&nbsp;</td><td>
64 byte alignment </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg4a9d7981e684056c93ec2fb8887f9736ee7d76124087fe07cbef17c2f1862574"></a><!-- doxytag: member="LUB_HEAP_ALIGN_2_POWER_7" ref="gg4a9d7981e684056c93ec2fb8887f9736ee7d76124087fe07cbef17c2f1862574" args="" -->LUB_HEAP_ALIGN_2_POWER_7</em>&nbsp;</td><td>
128 byte alignment </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg4a9d7981e684056c93ec2fb8887f973657e131b1e4f988a56e11c45a41b35d7f"></a><!-- doxytag: member="LUB_HEAP_ALIGN_2_POWER_8" ref="gg4a9d7981e684056c93ec2fb8887f973657e131b1e4f988a56e11c45a41b35d7f" args="" -->LUB_HEAP_ALIGN_2_POWER_8</em>&nbsp;</td><td>
256 byte alignment </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg4a9d7981e684056c93ec2fb8887f9736c7bb0e7133a6db470fef2a261f3bc846"></a><!-- doxytag: member="LUB_HEAP_ALIGN_2_POWER_9" ref="gg4a9d7981e684056c93ec2fb8887f9736c7bb0e7133a6db470fef2a261f3bc846" args="" -->LUB_HEAP_ALIGN_2_POWER_9</em>&nbsp;</td><td>
512 byte alignment </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg4a9d7981e684056c93ec2fb8887f97360dd3b4167c653e9fdcd9d21495eb245a"></a><!-- doxytag: member="LUB_HEAP_ALIGN_2_POWER_10" ref="gg4a9d7981e684056c93ec2fb8887f97360dd3b4167c653e9fdcd9d21495eb245a" args="" -->LUB_HEAP_ALIGN_2_POWER_10</em>&nbsp;</td><td>
1024 byte alignment (1KB) </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg4a9d7981e684056c93ec2fb8887f9736de1f122824b42b6d28571fe74a435de1"></a><!-- doxytag: member="LUB_HEAP_ALIGN_2_POWER_11" ref="gg4a9d7981e684056c93ec2fb8887f9736de1f122824b42b6d28571fe74a435de1" args="" -->LUB_HEAP_ALIGN_2_POWER_11</em>&nbsp;</td><td>
2048 byte alignment (2KB) </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg4a9d7981e684056c93ec2fb8887f9736649650c61c604be76e7a7828e6bc1a7d"></a><!-- doxytag: member="LUB_HEAP_ALIGN_2_POWER_12" ref="gg4a9d7981e684056c93ec2fb8887f9736649650c61c604be76e7a7828e6bc1a7d" args="" -->LUB_HEAP_ALIGN_2_POWER_12</em>&nbsp;</td><td>
4096 byte alignment (4KB) </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg4a9d7981e684056c93ec2fb8887f9736521e810c06ca710e30563cb6a72016d2"></a><!-- doxytag: member="LUB_HEAP_ALIGN_2_POWER_13" ref="gg4a9d7981e684056c93ec2fb8887f9736521e810c06ca710e30563cb6a72016d2" args="" -->LUB_HEAP_ALIGN_2_POWER_13</em>&nbsp;</td><td>
8192 byte alignment (8KB) </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg4a9d7981e684056c93ec2fb8887f9736fa070e706f53410ef46cd0bfc4a1001a"></a><!-- doxytag: member="LUB_HEAP_ALIGN_2_POWER_14" ref="gg4a9d7981e684056c93ec2fb8887f9736fa070e706f53410ef46cd0bfc4a1001a" args="" -->LUB_HEAP_ALIGN_2_POWER_14</em>&nbsp;</td><td>
16384 byte alignment (16KB) </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg4a9d7981e684056c93ec2fb8887f97362eedf6aa5d2a7202cf00fd6a40c4e0b7"></a><!-- doxytag: member="LUB_HEAP_ALIGN_2_POWER_15" ref="gg4a9d7981e684056c93ec2fb8887f97362eedf6aa5d2a7202cf00fd6a40c4e0b7" args="" -->LUB_HEAP_ALIGN_2_POWER_15</em>&nbsp;</td><td>
32768 byte alignment (32KB) </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg4a9d7981e684056c93ec2fb8887f9736762f5b6e073085f7462427a8031d85aa"></a><!-- doxytag: member="LUB_HEAP_ALIGN_2_POWER_16" ref="gg4a9d7981e684056c93ec2fb8887f9736762f5b6e073085f7462427a8031d85aa" args="" -->LUB_HEAP_ALIGN_2_POWER_16</em>&nbsp;</td><td>
65536 byte alignment (64KB) </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg4a9d7981e684056c93ec2fb8887f9736e009e682bf437fd1d33962453b9a801e"></a><!-- doxytag: member="LUB_HEAP_ALIGN_2_POWER_17" ref="gg4a9d7981e684056c93ec2fb8887f9736e009e682bf437fd1d33962453b9a801e" args="" -->LUB_HEAP_ALIGN_2_POWER_17</em>&nbsp;</td><td>
131072 byte alignment (128KB) </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg4a9d7981e684056c93ec2fb8887f9736c48f0c2cd91c5cfab9621d032f5b3fe0"></a><!-- doxytag: member="LUB_HEAP_ALIGN_2_POWER_18" ref="gg4a9d7981e684056c93ec2fb8887f9736c48f0c2cd91c5cfab9621d032f5b3fe0" args="" -->LUB_HEAP_ALIGN_2_POWER_18</em>&nbsp;</td><td>
262144 byte alignment (256KB) </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg4a9d7981e684056c93ec2fb8887f97368aea61b84276dd041b9283a20cd25195"></a><!-- doxytag: member="LUB_HEAP_ALIGN_2_POWER_19" ref="gg4a9d7981e684056c93ec2fb8887f97368aea61b84276dd041b9283a20cd25195" args="" -->LUB_HEAP_ALIGN_2_POWER_19</em>&nbsp;</td><td>
524288 byte alignment (512KB) </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg4a9d7981e684056c93ec2fb8887f973696ebbe8984583995e3127a7d4f432f14"></a><!-- doxytag: member="LUB_HEAP_ALIGN_2_POWER_20" ref="gg4a9d7981e684056c93ec2fb8887f973696ebbe8984583995e3127a7d4f432f14" args="" -->LUB_HEAP_ALIGN_2_POWER_20</em>&nbsp;</td><td>
1048576 byte alignment (1MB) </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg4a9d7981e684056c93ec2fb8887f97367edf625c4d38e98a49c570fcb2ad9132"></a><!-- doxytag: member="LUB_HEAP_ALIGN_2_POWER_21" ref="gg4a9d7981e684056c93ec2fb8887f97367edf625c4d38e98a49c570fcb2ad9132" args="" -->LUB_HEAP_ALIGN_2_POWER_21</em>&nbsp;</td><td>
2097152 byte alignment (2MB) </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg4a9d7981e684056c93ec2fb8887f973669c741dc10c45cdef99d9350ad99f6e5"></a><!-- doxytag: member="LUB_HEAP_ALIGN_2_POWER_22" ref="gg4a9d7981e684056c93ec2fb8887f973669c741dc10c45cdef99d9350ad99f6e5" args="" -->LUB_HEAP_ALIGN_2_POWER_22</em>&nbsp;</td><td>
4194304 byte alignment (4MB) </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg4a9d7981e684056c93ec2fb8887f9736f52a2a0d7b86c36a75f5e0e33027aca7"></a><!-- doxytag: member="LUB_HEAP_ALIGN_2_POWER_23" ref="gg4a9d7981e684056c93ec2fb8887f9736f52a2a0d7b86c36a75f5e0e33027aca7" args="" -->LUB_HEAP_ALIGN_2_POWER_23</em>&nbsp;</td><td>
8388608 byte alignment (8MB) </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg4a9d7981e684056c93ec2fb8887f973665c146f467678cee5db554f8478c5a9f"></a><!-- doxytag: member="LUB_HEAP_ALIGN_2_POWER_24" ref="gg4a9d7981e684056c93ec2fb8887f973665c146f467678cee5db554f8478c5a9f" args="" -->LUB_HEAP_ALIGN_2_POWER_24</em>&nbsp;</td><td>
16777216 byte alignment (16MB) </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg4a9d7981e684056c93ec2fb8887f973630e262cdf82aa7113ddc890a9bcfdcf2"></a><!-- doxytag: member="LUB_HEAP_ALIGN_2_POWER_25" ref="gg4a9d7981e684056c93ec2fb8887f973630e262cdf82aa7113ddc890a9bcfdcf2" args="" -->LUB_HEAP_ALIGN_2_POWER_25</em>&nbsp;</td><td>
33554432 byte alignment (32MB) </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg4a9d7981e684056c93ec2fb8887f973661a4f8875f89e580b58a50f79bb5ecc4"></a><!-- doxytag: member="LUB_HEAP_ALIGN_2_POWER_26" ref="gg4a9d7981e684056c93ec2fb8887f973661a4f8875f89e580b58a50f79bb5ecc4" args="" -->LUB_HEAP_ALIGN_2_POWER_26</em>&nbsp;</td><td>
67108864 byte alignment (64MB) </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg4a9d7981e684056c93ec2fb8887f9736c54203466584902578833230af7583f3"></a><!-- doxytag: member="LUB_HEAP_ALIGN_2_POWER_27" ref="gg4a9d7981e684056c93ec2fb8887f9736c54203466584902578833230af7583f3" args="" -->LUB_HEAP_ALIGN_2_POWER_27</em>&nbsp;</td><td>
134217728 byte alignment (128MB) </td></tr>
</table>
</dl>

</div>
</div><p>
<a class="anchor" name="gd4f0a8d6bc7b9f089520e9a7306ea071"></a><!-- doxytag: member="heap.h::lub_heap_show_e" ref="gd4f0a8d6bc7b9f089520e9a7306ea071" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__lub__heap.html#gd4f0a8d6bc7b9f089520e9a7306ea071">lub_heap_show_e</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This type defines how leak details should be displayed <dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="ggd4f0a8d6bc7b9f089520e9a7306ea0716ff186db1ca8cb6163cdac53566ebd47"></a><!-- doxytag: member="LUB_HEAP_SHOW_LEAKS" ref="ggd4f0a8d6bc7b9f089520e9a7306ea0716ff186db1ca8cb6163cdac53566ebd47" args="" -->LUB_HEAP_SHOW_LEAKS</em>&nbsp;</td><td>
Only show allocations which have no reference elsewhere in the system </td></tr>
<tr><td valign="top"><em><a class="anchor" name="ggd4f0a8d6bc7b9f089520e9a7306ea071eab056b0f57ef0562fc9b5a8ddf8cf44"></a><!-- doxytag: member="LUB_HEAP_SHOW_PARTIALS" ref="ggd4f0a8d6bc7b9f089520e9a7306ea071eab056b0f57ef0562fc9b5a8ddf8cf44" args="" -->LUB_HEAP_SHOW_PARTIALS</em>&nbsp;</td><td>
Only show allocations which have no direct reference elsewhere in the system, but do have their contents referenced. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="ggd4f0a8d6bc7b9f089520e9a7306ea071b9fc60896b467c4b220c1cfe75e721fc"></a><!-- doxytag: member="LUB_HEAP_SHOW_ALL" ref="ggd4f0a8d6bc7b9f089520e9a7306ea071b9fc60896b467c4b220c1cfe75e721fc" args="" -->LUB_HEAP_SHOW_ALL</em>&nbsp;</td><td>
Show all the current allocations in the system. </td></tr>
</table>
</dl>

</div>
</div><p>
<a class="anchor" name="gab49018edc28d9a3865814dab225ad20"></a><!-- doxytag: member="heap.h::lub_heap_status_t" ref="gab49018edc28d9a3865814dab225ad20" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__lub__heap.html#gab49018edc28d9a3865814dab225ad20">lub_heap_status_t</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This type is used to indicate the result of a dynamic memory allocation <dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="ggab49018edc28d9a3865814dab225ad208fb3cb26d3e20d3f99d058620d2f8c1e"></a><!-- doxytag: member="LUB_HEAP_OK" ref="ggab49018edc28d9a3865814dab225ad208fb3cb26d3e20d3f99d058620d2f8c1e" args="" -->LUB_HEAP_OK</em>&nbsp;</td><td>
The allocation was successful </td></tr>
<tr><td valign="top"><em><a class="anchor" name="ggab49018edc28d9a3865814dab225ad20488734ebe3ac87a3f061cb1e9e160228"></a><!-- doxytag: member="LUB_HEAP_FAILED" ref="ggab49018edc28d9a3865814dab225ad20488734ebe3ac87a3f061cb1e9e160228" args="" -->LUB_HEAP_FAILED</em>&nbsp;</td><td>
There was insufficient resource to satisfy the request </td></tr>
<tr><td valign="top"><em><a class="anchor" name="ggab49018edc28d9a3865814dab225ad209d6bd8c3b878a23cc8477a771a1204a1"></a><!-- doxytag: member="LUB_HEAP_DOUBLE_FREE" ref="ggab49018edc28d9a3865814dab225ad209d6bd8c3b878a23cc8477a771a1204a1" args="" -->LUB_HEAP_DOUBLE_FREE</em>&nbsp;</td><td>
An attempt has been made to release an already freed block of memory. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="ggab49018edc28d9a3865814dab225ad20a531672d67b6ca8e1d0e084ccb951e05"></a><!-- doxytag: member="LUB_HEAP_CORRUPTED" ref="ggab49018edc28d9a3865814dab225ad20a531672d67b6ca8e1d0e084ccb951e05" args="" -->LUB_HEAP_CORRUPTED</em>&nbsp;</td><td>
A memory corruption has been detected. e.g. someone writing beyond the bounds of an allocated block of memory. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="ggab49018edc28d9a3865814dab225ad20750287dac5ad1bc96e94bd66c2b5f033"></a><!-- doxytag: member="LUB_HEAP_INVALID_POINTER" ref="ggab49018edc28d9a3865814dab225ad20750287dac5ad1bc96e94bd66c2b5f033" args="" -->LUB_HEAP_INVALID_POINTER</em>&nbsp;</td><td>
The client has passed in an invalid pointer i.e. one which lies outside the bounds of the current heap. </td></tr>
</table>
</dl>

</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="g39480d0aba862821dde07cfcc1fd8ed3"></a><!-- doxytag: member="heap.h::lub_heap__get_max_free" ref="g39480d0aba862821dde07cfcc1fd8ed3" args="(lub_heap_t *instance)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t lub_heap__get_max_free           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__lub__heap.html#g129a7b63c896fb5058cbcbb865aee35a">lub_heap_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instance</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method provides the size, in bytes, of the largest allocation which can be performed. <dl class="pre" compact><dt><b>Precondition:</b></dt><dd><ul>
<li>The heap needs to have been created with an initial memory segment.</li></ul>
</dd></dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>size of largest possible allocation.</li></ul>
</dd></dl>
<dl class="post" compact><dt><b>Postcondition:</b></dt><dd><ul>
<li>none </li></ul>
</dd></dl>
<dl compact><dt><b>Parameters: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>instance</em>&nbsp;</td><td>
The instance on which to operate </td></tr>
</table>
</dl>
</div>
</div><p>
<a class="anchor" name="g3f01e771ee399c463a0cccb3c03965e8"></a><!-- doxytag: member="heap.h::lub_heap__get_stats" ref="g3f01e771ee399c463a0cccb3c03965e8" args="(lub_heap_t *instance, lub_heap_stats_t *stats)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lub_heap__get_stats           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__lub__heap.html#g129a7b63c896fb5058cbcbb865aee35a">lub_heap_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__lub__heap.html#g80ed67d3858c4e5783570afa6910e9c8">lub_heap_stats_t</a> *&nbsp;</td>
          <td class="paramname"> <em>stats</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This operation fills out a statistics structure with the details for the specified heap.<p>
<dl class="pre" compact><dt><b>Precondition:</b></dt><dd><ul>
<li>none</li></ul>
</dd></dl>
<dl class="post" compact><dt><b>Postcondition:</b></dt><dd><ul>
<li>the results filled out are a snapshot of the statistics as the time of the call. </li></ul>
</dd></dl>
<dl compact><dt><b>Parameters: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>instance</em>&nbsp;</td><td>
The instance on which to operate </td></tr>
<tr><td valign="top"><em>stats</em>&nbsp;</td><td>
A client provided structure to fill out with the heap details </td></tr>
</table>
</dl>
</div>
</div><p>
<a class="anchor" name="g5d43fb90d77f185f6cb9d012ae5074a5"></a><!-- doxytag: member="heap.h::lub_heap__set_framecount" ref="g5d43fb90d77f185f6cb9d012ae5074a5" args="(unsigned framecount)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lub_heap__set_framecount           </td>
          <td>(</td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>framecount</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>framecount</em>&nbsp;</td><td>
The new framecount to use </td></tr>
</table>
</dl>
</div>
</div><p>
<a class="anchor" name="g414a3c52b7b7169ac66f84d8a0878549"></a><!-- doxytag: member="heap.h::lub_heap_add_segment" ref="g414a3c52b7b7169ac66f84d8a0878549" args="(lub_heap_t *instance, void *start, size_t size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lub_heap_add_segment           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__lub__heap.html#g129a7b63c896fb5058cbcbb865aee35a">lub_heap_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This operation augments an existing heap with some more memory to manage. NB. if the memory happens to be follow on from the initial memory segment then the two will merge into a single larger segment. This means that a heap which is expanded with a sbrk() like mechanism will contain a single expandible segment.<p>
<dl class="pre" compact><dt><b>Precondition:</b></dt><dd><ul>
<li>The heap needs to have been create with an initial memory segment.</li></ul>
</dd></dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>none</li></ul>
</dd></dl>
<dl class="post" compact><dt><b>Postcondition:</b></dt><dd><ul>
<li>The new segment of memory becomes available for use by this heap. </li></ul>
</dd></dl>
<dl compact><dt><b>Parameters: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>instance</em>&nbsp;</td><td>
The heap instance on which to operate </td></tr>
<tr><td valign="top"><em>start</em>&nbsp;</td><td>
The beginning of the memory segment to be managed </td></tr>
<tr><td valign="top"><em>size</em>&nbsp;</td><td>
The number of bytes available for use in this segment </td></tr>
</table>
</dl>
</div>
</div><p>
<a class="anchor" name="gca4e146e51b8ba1a2cc61a739a66ad83"></a><!-- doxytag: member="heap.h::lub_heap_cache_init" ref="gca4e146e51b8ba1a2cc61a739a66ad83" args="(lub_heap_t *instance, lub_heap_align_t max_block_size, size_t num_max_blocks)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__lub__heap.html#gab49018edc28d9a3865814dab225ad20">lub_heap_status_t</a> lub_heap_cache_init           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__lub__heap.html#g129a7b63c896fb5058cbcbb865aee35a">lub_heap_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__lub__heap.html#g4a9d7981e684056c93ec2fb8887f9736">lub_heap_align_t</a>&nbsp;</td>
          <td class="paramname"> <em>max_block_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>num_max_blocks</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This operation adds a cache to the current heap, which speeds up the allocation and releasing of smaller block sizes.<p>
<dl class="pre" compact><dt><b>Precondition:</b></dt><dd><ul>
<li>The heap must have been initialised</li><li>This call must not have been made on this heap before</li></ul>
</dd></dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>LUB_HEAP_OK if the cache was successfully set up.</li><li>LUB_HEAP_FAILED if the cache was not set up for whatever reason</li></ul>
</dd></dl>
<dl class="post" compact><dt><b>Postcondition:</b></dt><dd><ul>
<li>memory allocations for smaller block sizes may come from the cache. </li></ul>
</dd></dl>
<dl compact><dt><b>Parameters: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>instance</em>&nbsp;</td><td>
The instance on which to operate </td></tr>
<tr><td valign="top"><em>max_block_size</em>&nbsp;</td><td>
The maximum block size for the cache </td></tr>
<tr><td valign="top"><em>num_max_blocks</em>&nbsp;</td><td>
The number of maximum sized blocks to make available. </td></tr>
</table>
</dl>
</div>
</div><p>
<a class="anchor" name="g1afa70ccf5e601fe5adc291475e9784c"></a><!-- doxytag: member="heap.h::lub_heap_check" ref="g1afa70ccf5e601fe5adc291475e9784c" args="(bool_t enable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__lub__types.html#g04dd5074964518403bf944f2b240a5f8">bool_t</a> lub_heap_check           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__lub__types.html#g04dd5074964518403bf944f2b240a5f8">bool_t</a>&nbsp;</td>
          <td class="paramname"> <em>enable</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This operation controls runtime heap corruption detection. This means that during every heap operation a full check is done of the specified heap, before any allocations/free are performed. This has a performance overhead but provides a valuable aid in finding a memory corrupting client. Corruption will be spotted the first time a memory operation is performed AFTER it has occured.<p>
By default checking is switched off.<p>
<dl class="pre" compact><dt><b>Precondition:</b></dt><dd><ul>
<li>none</li></ul>
</dd></dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>last checking status</li></ul>
</dd></dl>
<dl class="post" compact><dt><b>Postcondition:</b></dt><dd><ul>
<li>(enabled) the heap will have been scanned for any corruption and if found the return status of the invoking heap operation will be LUB_HEAP_CORRUPTED.</li><li>(disabled) no entire heap memory checking will occur. </li></ul>
</dd></dl>
<dl compact><dt><b>Parameters: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>enable</em>&nbsp;</td><td>
BOOL_TRUE to enable checking or BOOL_FALSE to disable </td></tr>
</table>
</dl>
</div>
</div><p>
<a class="anchor" name="g964ec29df1b3474a8bf08771c8f824dd"></a><!-- doxytag: member="heap.h::lub_heap_check_memory" ref="g964ec29df1b3474a8bf08771c8f824dd" args="(lub_heap_t *instance)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__lub__types.html#g04dd5074964518403bf944f2b240a5f8">bool_t</a> lub_heap_check_memory           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__lub__heap.html#g129a7b63c896fb5058cbcbb865aee35a">lub_heap_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instance</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This operation checks the integrety of the memory in the specified heap. Corruption will be spotted the first time a check is performed AFTER it has occured. <dl class="pre" compact><dt><b>Precondition:</b></dt><dd><ul>
<li>the specified heap will have been created</li></ul>
</dd></dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>BOOL_TRUE if the heap is OK</li><li>BOOL_FALSE if the heap is corrupted.</li></ul>
</dd></dl>
<dl class="post" compact><dt><b>Postcondition:</b></dt><dd><ul>
<li>none </li></ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="ge725109644e18f395eecc922b1bffa20"></a><!-- doxytag: member="heap.h::lub_heap_create" ref="ge725109644e18f395eecc922b1bffa20" args="(void *start, size_t size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__lub__heap.html#g129a7b63c896fb5058cbcbb865aee35a">lub_heap_t</a>* lub_heap_create           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This operation creates a dynamic heap from the provided memory segment.<p>
<dl class="pre" compact><dt><b>Precondition:</b></dt><dd><ul>
<li>none</li></ul>
</dd></dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>a reference to a heap object which can be used to allocate memory from the segments associated with this heap.</li></ul>
</dd></dl>
<dl class="post" compact><dt><b>Postcondition:</b></dt><dd><ul>
<li>memory allocations can be invoked on the returned intance.</li><li>further memory segements can be augmented to the heap using the <a class="el" href="group__lub__heap.html#g414a3c52b7b7169ac66f84d8a0878549">lub_heap_add_segment()</a> operation. </li></ul>
</dd></dl>
<dl compact><dt><b>Parameters: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>start</em>&nbsp;</td><td>
The begining of the first memory segment to associate with this heap </td></tr>
<tr><td valign="top"><em>size</em>&nbsp;</td><td>
The number of bytes available for use in the first segment. </td></tr>
</table>
</dl>
</div>
</div><p>
<a class="anchor" name="g17abaa12fe023d24618ca9cff747f009"></a><!-- doxytag: member="heap.h::lub_heap_destroy" ref="g17abaa12fe023d24618ca9cff747f009" args="(lub_heap_t *instance)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lub_heap_destroy           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__lub__heap.html#g129a7b63c896fb5058cbcbb865aee35a">lub_heap_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instance</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This operation creates a dynamic heap from the provided memory segment.<p>
<dl class="pre" compact><dt><b>Precondition:</b></dt><dd><ul>
<li>The heap needs to have been create with an initial memory segment.</li></ul>
</dd></dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>none</li></ul>
</dd></dl>
<dl class="post" compact><dt><b>Postcondition:</b></dt><dd><ul>
<li>The heap is no longer valid for use.</li><li>The memory segment(s) previously given to the heap may now be reused.</li><li>Any extra resources used for leak detection will have been released. </li></ul>
</dd></dl>
<dl compact><dt><b>Parameters: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>instance</em>&nbsp;</td><td>
The heap instance on which to operate </td></tr>
</table>
</dl>
</div>
</div><p>
<a class="anchor" name="gc00dba6172ae3b6c3084fd22fbd20d20"></a><!-- doxytag: member="heap.h::lub_heap_foreach_free_block" ref="gc00dba6172ae3b6c3084fd22fbd20d20" args="(lub_heap_t *instance, lub_heap_foreach_fn *fn, void *arg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lub_heap_foreach_free_block           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__lub__heap.html#g129a7b63c896fb5058cbcbb865aee35a">lub_heap_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__lub__heap.html#gddc3c39029814ce984a987e67293b3d9">lub_heap_foreach_fn</a> *&nbsp;</td>
          <td class="paramname"> <em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>arg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This operation is a diagnostic which can be used to iterate around all the free blocks in the specified heap. For example it may be desirable to output information about each of the free blocks present.<p>
<dl class="pre" compact><dt><b>Precondition:</b></dt><dd><ul>
<li>The heap needs to have been create with an initial memory segment.</li></ul>
</dd></dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>none</li></ul>
</dd></dl>
<dl class="post" compact><dt><b>Postcondition:</b></dt><dd>-The specified function will have been called once for every free block in the specified heap </dd></dl>
<dl compact><dt><b>Parameters: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>instance</em>&nbsp;</td><td>
The heap instance on which to operate </td></tr>
<tr><td valign="top"><em>fn</em>&nbsp;</td><td>
The client provided function to call for each free block </td></tr>
<tr><td valign="top"><em>arg</em>&nbsp;</td><td>
Some client specific data to pass through to the callback function. </td></tr>
</table>
</dl>
</div>
</div><p>
<a class="anchor" name="g36ab69b85984b310c774be3cfde95e02"></a><!-- doxytag: member="heap.h::lub_heap_foreach_segment" ref="g36ab69b85984b310c774be3cfde95e02" args="(lub_heap_t *instance, lub_heap_foreach_fn *fn, void *arg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lub_heap_foreach_segment           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__lub__heap.html#g129a7b63c896fb5058cbcbb865aee35a">lub_heap_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__lub__heap.html#gddc3c39029814ce984a987e67293b3d9">lub_heap_foreach_fn</a> *&nbsp;</td>
          <td class="paramname"> <em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>arg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This operation is a diagnostic which can be used to iterate around all the segments in the specified heap. For example it may be desirable to output information about each of the segments present.<p>
<dl class="pre" compact><dt><b>Precondition:</b></dt><dd><ul>
<li>The heap needs to have been create with an initial memory segment.</li></ul>
</dd></dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>none</li></ul>
</dd></dl>
<dl class="post" compact><dt><b>Postcondition:</b></dt><dd>-The specified function will have been called once for every segment in the specified heap </dd></dl>
<dl compact><dt><b>Parameters: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>instance</em>&nbsp;</td><td>
The heap instance on which to operate </td></tr>
<tr><td valign="top"><em>fn</em>&nbsp;</td><td>
The client provided function to call for each free block </td></tr>
<tr><td valign="top"><em>arg</em>&nbsp;</td><td>
Some client specific data to pass through to the callback function. </td></tr>
</table>
</dl>
</div>
</div><p>
<a class="anchor" name="g93612fe6821dedb10b7347f6a6b78193"></a><!-- doxytag: member="heap.h::lub_heap_init" ref="g93612fe6821dedb10b7347f6a6b78193" args="(const char *program_name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lub_heap_init           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>program_name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This operation is used to initialise the heap management subsystem <dl class="pre" compact><dt><b>Precondition:</b></dt><dd><ul>
<li>none</li></ul>
</dd></dl>
<dl class="post" compact><dt><b>Postcondition:</b></dt><dd><ul>
<li>The POSIX specific subsystem will be initialised to load the debugging symbols for the current executable. This enables the backtraces used for leak detection to show the full detail in the stack traces.</li><li>If the system is configured at build time without GPL support (disabled by default) then only the address of each stack frame will be shown. </li></ul>
</dd></dl>
<dl compact><dt><b>Parameters: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>program_name</em>&nbsp;</td><td>
The full pathname of the current executable This is typically obtained from argv[0] in main() </td></tr>
</table>
</dl>
</div>
</div><p>
<a class="anchor" name="g60c64a44f73c23d79922f5791a2a1c40"></a><!-- doxytag: member="heap.h::lub_heap_is_checking" ref="g60c64a44f73c23d79922f5791a2a1c40" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__lub__types.html#g04dd5074964518403bf944f2b240a5f8">bool_t</a> lub_heap_is_checking           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This operation indicates the current status of the full memory checking facility.<p>
<dl class="pre" compact><dt><b>Precondition:</b></dt><dd>none</dd></dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>BOOL_TRUE if full memory checking is enabled.</li><li>BOOL_FALSE if full memory checking is disabled.</li></ul>
</dd></dl>
<dl class="post" compact><dt><b>Postcondition:</b></dt><dd>none </dd></dl>

</div>
</div><p>
<a class="anchor" name="g16f1fd880a804c6eb2aec9a78f871565"></a><!-- doxytag: member="heap.h::lub_heap_is_tainting" ref="g16f1fd880a804c6eb2aec9a78f871565" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__lub__types.html#g04dd5074964518403bf944f2b240a5f8">bool_t</a> lub_heap_is_tainting           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This operation indicates the current status of the memory tainting facility<p>
<dl class="pre" compact><dt><b>Precondition:</b></dt><dd>none</dd></dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>BOOL_TRUE if memory tainting is enabled.</li><li>BOOL_FALSE if memory tainting is disabled.</li></ul>
</dd></dl>
<dl class="post" compact><dt><b>Postcondition:</b></dt><dd>none </dd></dl>

</div>
</div><p>
<a class="anchor" name="g27ea180a1810ac93058965062e6e9bfa"></a><!-- doxytag: member="heap.h::lub_heap_leak_report" ref="g27ea180a1810ac93058965062e6e9bfa" args="(lub_heap_show_e how, const char *substring)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__lub__types.html#g04dd5074964518403bf944f2b240a5f8">bool_t</a> lub_heap_leak_report           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__lub__heap.html#gd4f0a8d6bc7b9f089520e9a7306ea071">lub_heap_show_e</a>&nbsp;</td>
          <td class="paramname"> <em>how</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>substring</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function dumps all the context details for the heap to stdout. 'how' is one of the following values: 0 - show only leaks 1 - show partial leaks (no references to the start of the block) 2 - show all allocations (VERY VERBOSE)<p>
NB. if tainting is switched off then this function will not perform any memory scanning and will simply show all the allocated blocks.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>a boolean indicating whether any leaks were displayed or not. </li></ul>
</dd></dl>
<dl compact><dt><b>Parameters: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>how</em>&nbsp;</td><td>
how to display the details </td></tr>
<tr><td valign="top"><em>substring</em>&nbsp;</td><td>
an optional substring to use to filter contexts. Only contexts which contain the substring will be displayed </td></tr>
</table>
</dl>
</div>
</div><p>
<a class="anchor" name="gdc7dc0b4ef07595e2a07c0a4d6f982b6"></a><!-- doxytag: member="heap.h::lub_heap_leak_restore_detection" ref="gdc7dc0b4ef07595e2a07c0a4d6f982b6" args="(lub_heap_t *instance)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lub_heap_leak_restore_detection           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__lub__heap.html#g129a7b63c896fb5058cbcbb865aee35a">lub_heap_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instance</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This operation signals the end of a section of code which should not have any of it's heap usage monitored by the leak detection code.<p>
NB. you may nest the usage of <a class="el" href="group__lub__heap.html#g42d6914ff2ae2ab8f57e4b91dc8b9f0b">lub_heap_leak_suppress_detection()</a> and <a class="el" href="group__lub__heap.html#gdc7dc0b4ef07595e2a07c0a4d6f982b6">lub_heap_leak_restore_detection()</a> in which case only when the outermost section has been terminated will monitoring commence again.<p>
<dl class="pre" compact><dt><b>Precondition:</b></dt><dd><ul>
<li>The heap must have been initialised</li><li>lub_heap_start_unmonitored_section() must have been called.</li></ul>
</dd></dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>none</li></ul>
</dd></dl>
<dl class="post" compact><dt><b>Postcondition:</b></dt><dd><ul>
<li>If leak detection is enabled then no subsequent allocations will be monitored until the lub_heap_end_unmonitored_section() is called. </li></ul>
</dd></dl>
<dl compact><dt><b>Parameters: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>instance</em>&nbsp;</td><td>
The instance on which to operate </td></tr>
</table>
</dl>
</div>
</div><p>
<a class="anchor" name="g20d60ba7e27ab34023515c22a9f0a6c1"></a><!-- doxytag: member="heap.h::lub_heap_leak_scan" ref="g20d60ba7e27ab34023515c22a9f0a6c1" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lub_heap_leak_scan           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function scans memory to identify memory leaks<p>
NB. if tainting is switched off then this function may miss some leaks as references may remain in freed memory. 
</div>
</div><p>
<a class="anchor" name="g42d6914ff2ae2ab8f57e4b91dc8b9f0b"></a><!-- doxytag: member="heap.h::lub_heap_leak_suppress_detection" ref="g42d6914ff2ae2ab8f57e4b91dc8b9f0b" args="(lub_heap_t *instance)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lub_heap_leak_suppress_detection           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__lub__heap.html#g129a7b63c896fb5058cbcbb865aee35a">lub_heap_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instance</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This operation signals the start of a section of code which should not have any of it's heap usage monitored by the leak detection code.<p>
<dl class="pre" compact><dt><b>Precondition:</b></dt><dd><ul>
<li>The heap must have been initialised</li></ul>
</dd></dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>none</li></ul>
</dd></dl>
<dl class="post" compact><dt><b>Postcondition:</b></dt><dd><ul>
<li>If leak detection is enabled then no subsequent allocations will be monitored until the <a class="el" href="group__lub__heap.html#gdc7dc0b4ef07595e2a07c0a4d6f982b6">lub_heap_leak_restore_detection()</a> is called. </li></ul>
</dd></dl>
<dl compact><dt><b>Parameters: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>instance</em>&nbsp;</td><td>
The instance on which to operate </td></tr>
</table>
</dl>
</div>
</div><p>
<a class="anchor" name="gde5f3d9dbc7c208b6896e3e7f49b204a"></a><!-- doxytag: member="heap.h::lub_heap_overhead_size" ref="gde5f3d9dbc7c208b6896e3e7f49b204a" args="(lub_heap_align_t max_block_size, size_t num_max_blocks)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t lub_heap_overhead_size           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__lub__heap.html#g4a9d7981e684056c93ec2fb8887f9736">lub_heap_align_t</a>&nbsp;</td>
          <td class="paramname"> <em>max_block_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>num_max_blocks</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This operation returns the overhead, in bytes, which is required to implement a heap instance. This provide clients the means of calculating how much memory they need to assign for a heap instance to manage.<p>
<dl class="pre" compact><dt><b>Precondition:</b></dt><dd><ul>
<li>none</li></ul>
</dd></dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>size in bytes of the overhead required by a lub_heap instance.</li></ul>
</dd></dl>
<dl class="post" compact><dt><b>Postcondition:</b></dt><dd><ul>
<li>none </li></ul>
</dd></dl>
<dl compact><dt><b>Parameters: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>max_block_size</em>&nbsp;</td><td>
The maximum block size for the cache </td></tr>
<tr><td valign="top"><em>num_max_blocks</em>&nbsp;</td><td>
The number of maximum sized blocks to make available. </td></tr>
</table>
</dl>
</div>
</div><p>
<a class="anchor" name="g46a1d39d0d3661a4698ce0d3ac838856"></a><!-- doxytag: member="heap.h::lub_heap_realloc" ref="g46a1d39d0d3661a4698ce0d3ac838856" args="(lub_heap_t *instance, char **ptr, size_t size, lub_heap_align_t alignment)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__lub__heap.html#gab49018edc28d9a3865814dab225ad20">lub_heap_status_t</a> lub_heap_realloc           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__lub__heap.html#g129a7b63c896fb5058cbcbb865aee35a">lub_heap_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__lub__heap.html#g4a9d7981e684056c93ec2fb8887f9736">lub_heap_align_t</a>&nbsp;</td>
          <td class="paramname"> <em>alignment</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This operation changes the size of the object referenced by a passed in pointer to "size". The contents will be unchanged up to the minimum of the old and new sizes. If the new size is larger, the new space is uninitialised.<p>
<dl class="pre" compact><dt><b>Precondition:</b></dt><dd><ul>
<li>The heap needs to have been created with an initial memory segment.</li><li>If "*ptr" contains a non-NULL value then this MUST have been allocated using this operation, from the same heap instance.</li></ul>
</dd></dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>the status of the operation.</li></ul>
</dd></dl>
<dl class="post" compact><dt><b>Postcondition:</b></dt><dd><ul>
<li>The client takes responsiblity for releasing any allocated memory when they are finished with it.</li><li>If *ptr contains a non-NULL value, then after a succesfull call, the initial memory referenced by it may have been released for reuse, and the pointer modified to reference some new memory.</li><li>*ptr may contain NULL in which case no memory will be released back to the heap for reuse, and the pointer is filled out with the allocated memory.</li><li>(size == 0) No new memory will be allocated, *ptr will be set to NULL, and any original memory referenced by it will have been released. </li></ul>
</dd></dl>
<dl compact><dt><b>Parameters: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>instance</em>&nbsp;</td><td>
The heap instance on which to operate </td></tr>
<tr><td valign="top"><em>ptr</em>&nbsp;</td><td>
Reference to a pointer containing previously allocated memory or NULL. </td></tr>
<tr><td valign="top"><em>size</em>&nbsp;</td><td>
The number of bytes required for the object </td></tr>
<tr><td valign="top"><em>alignment</em>&nbsp;</td><td>
The alignement required for a new allocations. </td></tr>
</table>
</dl>
</div>
</div><p>
<a class="anchor" name="g9d0e743dc5ea4c92d5ad46a337b9bb29"></a><!-- doxytag: member="heap.h::lub_heap_show" ref="g9d0e743dc5ea4c92d5ad46a337b9bb29" args="(lub_heap_t *instance, bool_t verbose)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lub_heap_show           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__lub__heap.html#g129a7b63c896fb5058cbcbb865aee35a">lub_heap_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__lub__types.html#g04dd5074964518403bf944f2b240a5f8">bool_t</a>&nbsp;</td>
          <td class="paramname"> <em>verbose</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This operation dumps the salient details of the specified heap to stdout <dl compact><dt><b>Parameters: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>instance</em>&nbsp;</td><td>
The instance on which to operate </td></tr>
<tr><td valign="top"><em>verbose</em>&nbsp;</td><td>
Whether to be verbose or not </td></tr>
</table>
</dl>
</div>
</div><p>
<a class="anchor" name="g90b9231dfa57d8846cc821b58d5625d5"></a><!-- doxytag: member="heap.h::lub_heap_static_alloc" ref="g90b9231dfa57d8846cc821b58d5625d5" args="(lub_heap_t *instance, size_t size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* lub_heap_static_alloc           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__lub__heap.html#g129a7b63c896fb5058cbcbb865aee35a">lub_heap_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This operation allocates some "static" memory from a heap. This is memory which will remain allocted for the lifetime of the heap instance. "static" memory allocation has zero overhead and causes zero fragmentation.<p>
NB. static allocation are only handed out from the first memory segment<p>
<dl class="pre" compact><dt><b>Precondition:</b></dt><dd><ul>
<li>The heap needs to have been created with an initial memory segment.</li></ul>
</dd></dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>a pointer to some "static" memory which will be fixed for the remaining lifetime of this heap.</li></ul>
</dd></dl>
<dl class="post" compact><dt><b>Postcondition:</b></dt><dd><ul>
<li>The client cannot ever free this memory although if the heap is managing memory which itself has been dynamically allocated, then the memory will be recovered when the heap is released. </li></ul>
</dd></dl>
<dl compact><dt><b>Parameters: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>instance</em>&nbsp;</td><td>
The heap instance on which to operate </td></tr>
<tr><td valign="top"><em>size</em>&nbsp;</td><td>
The number of bytes to allocate </td></tr>
</table>
</dl>
</div>
</div><p>
<a class="anchor" name="gc7aad687710900748aa05874abf1dfbf"></a><!-- doxytag: member="heap.h::lub_heap_stop_here" ref="gc7aad687710900748aa05874abf1dfbf" args="(lub_heap_status_t status, char *old_ptr, size_t new_size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lub_heap_stop_here           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__lub__heap.html#gab49018edc28d9a3865814dab225ad20">lub_heap_status_t</a>&nbsp;</td>
          <td class="paramname"> <em>status</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>old_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>new_size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function is invoked whenever a call to <a class="el" href="group__lub__heap.html#g46a1d39d0d3661a4698ce0d3ac838856">lub_heap_realloc()</a> fails. It is provided as a debugging aid; simple set a breakpoint to stop execution of the program and any failures will be caught in context. <dl compact><dt><b>Parameters: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>status</em>&nbsp;</td><td>
The failure status of the the call to realloc </td></tr>
<tr><td valign="top"><em>old_ptr</em>&nbsp;</td><td>
The old value of the pointer passed in </td></tr>
<tr><td valign="top"><em>new_size</em>&nbsp;</td><td>
The requested number of bytes </td></tr>
</table>
</dl>
</div>
</div><p>
<a class="anchor" name="g477f92c6ee9e1195dcdd1e915fc6b4fd"></a><!-- doxytag: member="heap.h::lub_heap_taint" ref="g477f92c6ee9e1195dcdd1e915fc6b4fd" args="(bool_t enable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__lub__types.html#g04dd5074964518403bf944f2b240a5f8">bool_t</a> lub_heap_taint           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__lub__types.html#g04dd5074964518403bf944f2b240a5f8">bool_t</a>&nbsp;</td>
          <td class="paramname"> <em>enable</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This operation controls the tainted memory facility. This means that during certain heap operations memory can be filled with some well defined bit patterns. This causes a slight performance overhead but can be used to shake out bugs such and free-memory-reads and uninitialised-memory-reads<p>
By default tainting is switched off.<p>
<dl class="pre" compact><dt><b>Precondition:</b></dt><dd><ul>
<li>none</li></ul>
</dd></dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>last tainted status</li></ul>
</dd></dl>
<dl class="post" compact><dt><b>Postcondition:</b></dt><dd><ul>
<li>(enabled) when a memory segment is given to a heap (either at creation or later) the contents will be set to 0xBB</li><li>(enabled) when some dynamically allocated memory is released back to a heap the contents will be set to 0xFF</li><li>(enabled) when some dynamic or static memory is allocated the contents will be set to 0xAA as the "uninitialised" value.</li><li>(disabled) no memory tainting will occur. </li></ul>
</dd></dl>
<dl compact><dt><b>Parameters: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>enable</em>&nbsp;</td><td>
BOOL_TRUE to enable tainting or BOOL_FALSE to disable </td></tr>
</table>
</dl>
</div>
</div><p>
<a class="anchor" name="gd83809882c37206aaed3f1f3ddb9d4dd"></a><!-- doxytag: member="partition.h::lub_partition_check_memory" ref="gd83809882c37206aaed3f1f3ddb9d4dd" args="(lub_partition_t *instance)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__lub__types.html#g04dd5074964518403bf944f2b240a5f8">bool_t</a> lub_partition_check_memory           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__lub__heap.html#g5ba9b552695e0934df61f2f1e0ec2d80">lub_partition_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instance</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This operation checks the integrety of the memory in the specified partition. Corruption will be spotted the first time a check is performed AFTER it has occured. <dl class="pre" compact><dt><b>Precondition:</b></dt><dd><ul>
<li>the specified partition will have been created</li></ul>
</dd></dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>BOOL_TRUE if the partition is OK</li><li>BOOL_FALSE if the partition is corrupted.</li></ul>
</dd></dl>
<dl class="post" compact><dt><b>Postcondition:</b></dt><dd><ul>
<li>none </li></ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="g5a8b738751f94f68f3177c9ec63df4ad"></a><!-- doxytag: member="partition.h::lub_partition_create" ref="g5a8b738751f94f68f3177c9ec63df4ad" args="(const lub_partition_spec_t *spec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__lub__heap.html#g5ba9b552695e0934df61f2f1e0ec2d80">lub_partition_t</a>* lub_partition_create           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__lub__heap.html#g7d39531da84d325c30559c533724c938">lub_partition_spec_t</a> *&nbsp;</td>
          <td class="paramname"> <em>spec</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This operation creates a partition<p>
<dl class="pre" compact><dt><b>Precondition:</b></dt><dd><ul>
<li>The system pool needs to be accessible</li></ul>
</dd></dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>a reference to a partition object which can be used to allocate memory</li></ul>
</dd></dl>
<dl class="post" compact><dt><b>Postcondition:</b></dt><dd><ul>
<li>memory allocations can be invoked on the returned intance. </li></ul>
</dd></dl>
<dl compact><dt><b>Parameters: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>spec</em>&nbsp;</td><td>
This is used to specify the details to be used for the partition. </td></tr>
</table>
</dl>
</div>
</div><p>
<a class="anchor" name="g1bed2bfd16e60ffe42da7e0a6c3d11d3"></a><!-- doxytag: member="partition.h::lub_partition_kill" ref="g1bed2bfd16e60ffe42da7e0a6c3d11d3" args="(lub_partition_t *instance)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lub_partition_kill           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__lub__heap.html#g5ba9b552695e0934df61f2f1e0ec2d80">lub_partition_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instance</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This operation starts the process of killing a partition.<p>
<dl class="pre" compact><dt><b>Precondition:</b></dt><dd><ul>
<li>The partition needs to have been created.</li></ul>
</dd></dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>none</li></ul>
</dd></dl>
<dl class="post" compact><dt><b>Postcondition:</b></dt><dd><ul>
<li>The partition will no longer hand out memory.</li><li>When the final outstanding piece of memory is handed back the partition will destroy itself.</li><li>Upon final destruction any resources obtained from the system pool will be returned. </li></ul>
</dd></dl>
<dl compact><dt><b>Parameters: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>instance</em>&nbsp;</td><td>
The heap instance on which to operate </td></tr>
</table>
</dl>
</div>
</div><p>
<a class="anchor" name="g8683176aa50668eb765ab17c421cc5d8"></a><!-- doxytag: member="partition.h::lub_partition_realloc" ref="g8683176aa50668eb765ab17c421cc5d8" args="(lub_partition_t *instance, char **ptr, size_t size, lub_heap_align_t alignment)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__lub__heap.html#gab49018edc28d9a3865814dab225ad20">lub_heap_status_t</a> lub_partition_realloc           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__lub__heap.html#g5ba9b552695e0934df61f2f1e0ec2d80">lub_partition_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__lub__heap.html#g4a9d7981e684056c93ec2fb8887f9736">lub_heap_align_t</a>&nbsp;</td>
          <td class="paramname"> <em>alignment</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This operation changes the size of the object referenced by a passed in pointer to "size". The contents will be unchanged up to the minimum of the old and new sizes. If the new size is larger, the new space is uninitialised.<p>
<dl class="pre" compact><dt><b>Precondition:</b></dt><dd><ul>
<li>The partition needs to have been created.</li><li>If "*ptr" contains a non-NULL value then this MUST have been allocated using this operation, from the same heap instance.</li></ul>
</dd></dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>the status of the operation.</li></ul>
</dd></dl>
<dl class="post" compact><dt><b>Postcondition:</b></dt><dd><ul>
<li>The client takes responsiblity for releasing any allocated memory when they are finished with it.</li><li>If *ptr contains a non-NULL value, then after a succesfull call, the initial memory referenced by it may have been released for reuse, and the pointer modified to reference some new memory.</li><li>*ptr may contain NULL in which case no memory will be released back to the heap for reuse, and the pointer is filled out with the allocated memory.</li><li>(size == 0) No new memory will be allocated, *ptr will be set to NULL, and any original memory referenced by it will have been released. </li></ul>
</dd></dl>
<dl compact><dt><b>Parameters: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>instance</em>&nbsp;</td><td>
The partition instance on which to operate </td></tr>
<tr><td valign="top"><em>ptr</em>&nbsp;</td><td>
Reference to a pointer containing previously allocated memory or NULL. </td></tr>
<tr><td valign="top"><em>size</em>&nbsp;</td><td>
The number of bytes required for the object </td></tr>
<tr><td valign="top"><em>alignment</em>&nbsp;</td><td>
The alignment required for a new allocations. </td></tr>
</table>
</dl>
</div>
</div><p>
<a class="anchor" name="g98c3c0f4e14c47ff7e0b1b1c93027203"></a><!-- doxytag: member="partition.h::lub_partition_show" ref="g98c3c0f4e14c47ff7e0b1b1c93027203" args="(lub_partition_t *instance, bool_t verbose)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lub_partition_show           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__lub__heap.html#g5ba9b552695e0934df61f2f1e0ec2d80">lub_partition_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__lub__types.html#g04dd5074964518403bf944f2b240a5f8">bool_t</a>&nbsp;</td>
          <td class="paramname"> <em>verbose</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This operation dumps the salient details of the specified partition to stdout <dl compact><dt><b>Parameters: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>instance</em>&nbsp;</td><td>
The instance on which to operate </td></tr>
<tr><td valign="top"><em>verbose</em>&nbsp;</td><td>
Whether to be verbose or not </td></tr>
</table>
</dl>
</div>
</div><p>
<a class="anchor" name="g98a8a9e389f033b1ba2a47cf1c9c173d"></a><!-- doxytag: member="partition.h::lub_partition_stop_here" ref="g98a8a9e389f033b1ba2a47cf1c9c173d" args="(lub_heap_status_t status, char *old_ptr, size_t new_size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lub_partition_stop_here           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__lub__heap.html#gab49018edc28d9a3865814dab225ad20">lub_heap_status_t</a>&nbsp;</td>
          <td class="paramname"> <em>status</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>old_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>new_size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function is invoked whenever a call to <a class="el" href="group__lub__heap.html#g8683176aa50668eb765ab17c421cc5d8">lub_partition_realloc()</a> fails. It is provided as a debugging aid; simple set a breakpoint to stop execution of the program and any failures will be caught in context. <dl compact><dt><b>Parameters: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>status</em>&nbsp;</td><td>
The failure status of the the call to realloc </td></tr>
<tr><td valign="top"><em>old_ptr</em>&nbsp;</td><td>
The old value of the pointer passed in </td></tr>
<tr><td valign="top"><em>new_size</em>&nbsp;</td><td>
The requested number of bytes </td></tr>
</table>
</dl>
</div>
</div><p>
<hr size="1"><address style="align: right;"><small>Generated on Tue Apr 29 13:41:09 2008 for CLISH by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.1 </small></address>
</body>
</html>
